{
  "version": 3,
  "sources": ["node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/native/src/config.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/manager/src/api.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/native/src/manager.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/native/src/url.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/native/src/service.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/native/src/history.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/native/src/page.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/emitter/src/api.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/native/src/transition.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/native/src/app.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/native/src/pjax.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/native/src/router.ts", "node_modules/.pnpm/@okikio/native@1.3.0/node_modules/@okikio/animate/src/api.ts", "build/ts/toArr.ts", "build/ts/services/IntroAnimation.ts", "build/ts/services/Navbar.ts", "build/ts/services/Image.ts", "build/ts/services/Carousel.ts", "build/ts/transitions/Fade.ts", "build/ts/main.ts"],
  "sourcesContent": ["export interface ICONFIG {\r\n    prefix?: string;\r\n    wrapperAttr?: string;\r\n    noAjaxLinkAttr?: string;\r\n    noPrefetchAttr?: \"no-prefetch\";\r\n    headers?: string[][];\r\n    preventSelfAttr?: string;\r\n    preventAllAttr?: string;\r\n    transitionAttr?: string;\r\n    blockAttr?: string;\r\n    timeout?: number;\r\n    [key: string]: any;\r\n}\r\n\r\nexport const CONFIG_DEFAULTS: ICONFIG = {\r\n    wrapperAttr: \"wrapper\",\r\n    noAjaxLinkAttr: \"no-ajax-link\",\r\n    noPrefetchAttr: \"no-prefetch\",\r\n    headers: [\r\n        [\"x-partial\", \"true\"]\r\n    ],\r\n    preventSelfAttr: `prevent=\"self\"`,\r\n    preventAllAttr: `prevent=\"all\"`,\r\n    transitionAttr: \"transition\",\r\n    blockAttr: `block`,\r\n    timeout: 30000\r\n};\r\n\r\nexport type ConfigKeys = keyof ICONFIG;\r\nexport const newConfig = (config: ICONFIG): ICONFIG => {\r\n    return Object.assign({ ...CONFIG_DEFAULTS }, config);\r\n};\r\n\r\n/** Converts string into properly formatted data attributes */\r\nexport const toAttr = (config: ICONFIG, value: string, brackets: boolean = true): string => {\r\n    let { prefix } = config;\r\n    let attr = `data${prefix ? \"-\" + prefix : \"\"}-${value}`;\r\n    return brackets ? `[${attr}]` : attr;\r\n};\r\n\r\n/** Selects config vars, and formats them for use, or simply returns the current configurations for the framework */\r\nexport const getConfig = (config: ICONFIG, value?: ConfigKeys, brackets: boolean = true): any => {\r\n    if (typeof value !== \"string\")\r\n        return config;\r\n\r\n    let prop = config[value];\r\n    if (typeof prop === \"string\")\r\n        return toAttr(config, prop, brackets);\r\n    return prop;\r\n};\r\n", "/** Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data */\r\nexport class Manager<K, V> {\r\n\t/** The complex list of named data, to which the Manager controls */\r\n\tpublic map: Map<K, V>;\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/** Returns the Manager classes base Map */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/** Get a value stored in the Manager */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/** Returns the keys of all items stored in the Manager as an Array */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn Array.from(this.map.keys());\r\n\t}\r\n\r\n\t/** Returns the values of all items stored in the Manager as an Array */\r\n\tpublic values(): Array<V> {\r\n\t\treturn Array.from(this.map.values());\r\n\t}\r\n\r\n\t/** Set a value to the Manager using a key */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\tlet size = this.size;\r\n\t\t// @ts-ignore\r\n\t\tlet num: K = size as K;\r\n\t\tthis.set(num, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Returns the total number of items stored in the Manager */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/** An alias for size */\r\n\tpublic get length(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/** Returns the last item in the Manager who's index is a certain distance from the last item in the Manager */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/** Removes a value stored in the Manager via a key, returns true if an element in the Map object existed and has been removed, or false if the element does not exist */\r\n\tpublic delete(key: K): boolean {\r\n\t\treturn this.map.delete(key);\r\n\t}\r\n\r\n\t/** Removes a value stored in the Manager via a key, returns the Manager class, allowing for chains */\r\n\tpublic remove(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Clear the Manager of all its contents */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Checks if the Manager contains a certain key */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/** Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order. */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/** Iterates through the Managers contents, calling a callback function every iteration */\r\n\tpublic forEach(\r\n\t\tcallback: (value?: V, key?: K, map?: Map<K, V>) => void,\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Allows for iteration via for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators] */\r\n\tpublic [Symbol.iterator](): IterableIterator<[K, V]> {\r\n\t\treturn this.entries();\r\n\t}\r\n}\r\n\r\n/**\r\n * Calls the method of a certain name for all items that are currently installed\r\n */\r\nexport const methodCall = (manager: Manager<any, any>, method: string, ...args: any): void => {\r\n\tmanager.forEach((item) => {\r\n\t\t// @ts-ignore\r\n\t\titem[method](...args);\r\n\t});\r\n};\r\n\r\n/**\r\n * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n */\r\nexport const asyncMethodCall = async (manager: Manager<any, any>, method: string, ...args: any): Promise<void> => {\r\n\tfor (let [, item] of manager) {\r\n\t\t// @ts-ignore\r\n\t\tawait item[method](...args);\r\n\t}\r\n};\r\n\r\nexport default Manager;\r\n", "import { Manager, methodCall, asyncMethodCall } from \"@okikio/manager\";\r\nimport { ICONFIG } from \"./config\";\r\nimport { IApp } from \"./app\";\r\nimport { EventEmitter } from \"./emitter\";\r\n\r\nexport type IAdvancedManager = AdvancedManager<any, ManagerItem>;\r\n\r\n/** The base class for AdvancedManager items */\r\nexport class ManagerItem {\r\n    /** The AdvancedManager the ManagerItem is attached to */\r\n    public manager: IAdvancedManager;\r\n\r\n    /** The App the ManagerItem is attached to */\r\n    public app: IApp;\r\n\r\n    /** The Config of the App the ManagerItem is attached to */\r\n    public config: ICONFIG;\r\n\r\n    /** The EventEmitter of the App the ManagerItem is attached to */\r\n    public emitter: EventEmitter;\r\n\r\n    /** The key to where ManagerItem is stored in an AdvancedManager */\r\n    public key: any;\r\n\r\n    constructor() { }\r\n\r\n    /** Run after the Manager Item has been registered */\r\n    public install(): any { }\r\n\r\n    /** Register the current Manager Item's manager */\r\n    public register(manager: IAdvancedManager, key: any): ManagerItem {\r\n        this.manager = manager;\r\n        this.app = manager.app;\r\n        this.config = manager.config;\r\n        this.emitter = manager.emitter;\r\n        this.key = key;\r\n        this.install();\r\n        return this;\r\n    }\r\n\r\n    /** Run before the ManagerItem has been unregistered */\r\n    public uninstall(): any { }\r\n\r\n    /** Basically removes a ManagerItem, in order to recover the ManagerItem, it needs to be re-added to an AdvancedManager */\r\n    public unregister() {\r\n        this.uninstall();\r\n\r\n        this.manager.remove(this.key);\r\n        this.key = undefined;\r\n        this.manager = undefined;\r\n        this.app = undefined;\r\n        this.config = undefined;\r\n        this.emitter = undefined;\r\n    }\r\n}\r\n\r\n/** A tweak to the Manager class that makes it self aware of the App class it's instantiated in */\r\nexport class AdvancedManager<K, V extends ManagerItem> extends Manager<K, V> {\r\n    /** The App the AdvancedManager is attached to */\r\n    public app: IApp;\r\n\r\n    /** The Config of the App the AdvancedManager is attached to */\r\n    public config: ICONFIG;\r\n\r\n    /** The EventEmitter of the App the AdvancedManager is attached to */\r\n    public emitter: EventEmitter;\r\n\r\n    /** Register App details */\r\n    constructor(app: IApp) {\r\n        super();\r\n        this.app = app;\r\n        this.config = app.config;\r\n        this.emitter = app.emitter;\r\n    }\r\n\r\n    /** Add a ManagerItem to AdvancedManager at a specified key */\r\n    public set(key: K, value: V) {\r\n        super.set(key, value);\r\n        value.register(this, key);\r\n        return this;\r\n    }\r\n}\r\n\r\nexport { Manager, methodCall, asyncMethodCall };\r\n", "export const newURL = (url: string | URL | Location = window.location.href): URL => {\r\n    return url instanceof URL ? url : new URL(url as unknown as string, window.location.origin);\r\n};\r\n\r\n/** Returns the pathname with the hash at the end */\r\nexport const getHashedPath = (url: URL): string => (`${url.pathname}${url.hash}`);\r\n\r\n/** Returns the actual hash without the hashtag */\r\nexport const getHash = (url: URL): string => (url.hash.slice(1));\r\n\r\n/** Removes the hash from the full URL for a clean URL string */\r\nexport const clean = (url: URL): string => (url.toString().replace(/(\\/#.*|\\/|#.*)$/, ''));\r\n\r\n/** Compares two URLs to each other */\r\nexport const equal = (a: URL | string, b: URL | string): boolean => {\r\n    let urlA = newURL(a);\r\n    let urlB = newURL(b);\r\n    return clean(urlA) === clean(urlB);\r\n};\r\n", "import { AdvancedManager, ManagerItem, methodCall } from \"./manager\";\r\nimport { IApp } from \"./app\";\r\n\r\n/** Controls specific kinds of actions that require JS */\r\nexport class Service extends ManagerItem {\r\n\t/** Called before the start of a Service, represents a constructor of sorts */\r\n\tpublic init(...args: any): any;\r\n\tpublic init(): any { }\r\n\r\n\t/** Called on start of Service */\r\n\tpublic boot(...args: any): any;\r\n\tpublic boot(): any {\r\n\t\tthis.initEvents();\r\n\t}\r\n\r\n\t/** Initialize events */\r\n\tpublic initEvents(): void { }\r\n\r\n\t/** Stop events */\r\n\tpublic stopEvents(): void { }\r\n\r\n\t/** Stop services */\r\n\tpublic stop(): void {\r\n\t\tthis.stopEvents();\r\n\t\tthis.unregister();\r\n\t}\r\n}\r\n\r\n/** The Service Manager controls the lifecycle of all Services in an App */\r\nexport class ServiceManager extends AdvancedManager<string, Service> {\r\n\tconstructor(app: IApp) {\r\n\t\tsuper(app);\r\n\t}\r\n\r\n\t/** Call the init method for all Services */\r\n\tpublic init(): ServiceManager {\r\n\t\tmethodCall(this, \"init\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Call the boot method for all Services */\r\n\tpublic boot(): ServiceManager {\r\n\t\tmethodCall(this, \"boot\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Call the stop method for all Services */\r\n\tpublic stop(): ServiceManager {\r\n\t\tmethodCall(this, \"stop\");\r\n\t\treturn this;\r\n\t}\r\n}\r\n", "import { Service } from \"./service\";\r\nimport { getHashedPath, newURL } from \"./url\";\r\n\r\nexport type Trigger = HTMLAnchorElement | \"HistoryManager\" | \"popstate\" | \"back\" | \"forward\";\r\nexport interface ICoords {\r\n\treadonly x: number;\r\n\treadonly y: number;\r\n}\r\n\r\nexport interface IStateData {\r\n\tscroll: ICoords;\r\n\t[key: string]: any;\r\n}\r\n\r\nexport interface IState {\r\n\turl: string;\r\n\tindex?: number;\r\n\ttransition: string;\r\n\tdata: IStateData;\r\n}\r\n\r\nexport interface IHistoryItem {\r\n\tindex: number;\r\n\tstates: IState[];\r\n}\r\n\r\nexport interface IHistoryManager extends Service {\r\n\tstates: IState[],\r\n\tpointer: number,\r\n\r\n\tinit(): any,\r\n\tget(index: number): IState,\r\n\tadd(value?: IState, historyAction?: \"replace\" | \"push\"): HistoryManager,\r\n\tremove(index?: number): HistoryManager,\r\n\treplace(newStates: IState[]): HistoryManager,\r\n\tset(i: number, state: IState): IState,\r\n\tcurrent: IState,\r\n\tlast: IState,\r\n\tprevious: IState | null,\r\n\tlength: number,\r\n}\r\n\r\n/** A quick snapshot of page scroll coordinates */\r\nexport const newCoords = (x: number = window.scrollX, y: number = window.scrollY): ICoords => ({ x, y });\r\n\r\n/** Creates a state; a state represents the current status of the page consisting of properties like: url, transition, and data */\r\nexport const newState = (state: IState = {\r\n\turl: getHashedPath(newURL()),\r\n\tindex: 0,\r\n\ttransition: \"default\",\r\n\tdata: {\r\n\t\tscroll: newCoords(),\r\n\t\ttrigger: \"HistoryManager\"\r\n\t}\r\n}): IState => (state);\r\n\r\n/** Keeps a record of the history of the App; it stores only the states of Pages */\r\nexport class HistoryManager extends Service implements IHistoryManager {\r\n\tpublic states: IState[];\r\n\tpublic pointer = -1;\r\n\r\n\t/** Initializes the states array, and replace the history pushState data with the states array */\r\n\tinit() {\r\n\t\tthis.states = [];\r\n\r\n\t\tlet state = newState();\r\n\t\tthis.add(state, \"replace\");\r\n\t}\r\n\r\n\t/** Get a state based on it's index */\r\n\tpublic get(index: number) {\r\n\t\treturn this.states[index];\r\n\t}\r\n\r\n\t/** Add a state to HistoryManager and change the history pushState data based on the historyAction specified */\r\n\tpublic add(value?: IState, historyAction: \"replace\" | \"push\" = \"push\"): HistoryManager {\r\n\t\tlet state = newState(value);\r\n\t\tlet len = this.length;\r\n\t\tthis.states.push({ ...state });\r\n\t\tthis.pointer = len;\r\n\r\n\t\tlet item: IHistoryItem = {\r\n\t\t\tindex: this.pointer,\r\n\t\t\tstates: [...this.states]\r\n\t\t};\r\n\t\tchangeState(historyAction, state, item);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic remove(index?: number) {\r\n\t\tif (index) {\r\n\t\t\tthis.states.splice(index, 1);\r\n\t\t} else {\r\n\t\t\tthis.states.pop();\r\n\t\t}\r\n\r\n\t\tthis.pointer--;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Replaces the states array with another states array, this is later used when going back and forward in page history */\r\n\tpublic replace(newStates: IState[]) {\r\n\t\tthis.states = newStates;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Set state by index. */\r\n\tpublic set(i: number, state: IState) {\r\n\t\treturn (this.states[i] = state);\r\n\t}\r\n\r\n\t/** Get the current state */\r\n\tget current(): IState {\r\n\t\treturn this.get(this.pointer);\r\n\t}\r\n\r\n\t/** Get the last state (top of the history stack). */\r\n\tget last(): IState {\r\n\t\treturn this.get(this.length - 1);\r\n\t}\r\n\r\n\t/** Get the previous state. */\r\n\tget previous(): IState | null {\r\n\t\treturn this.pointer < 1 ? null : this.get(this.pointer - 1);\r\n\t}\r\n\r\n\tget length() {\r\n\t\treturn this.states.length;\r\n\t}\r\n}\r\n\r\n/** Either push or replace history state */\r\nexport const changeState = (action: \"push\" | \"replace\", state: IState, item: object) => {\r\n\tlet href = getHashedPath(newURL(state.url));\r\n\tlet args = [item, \"\", href];\r\n\tif (window.history) {\r\n\t\tswitch (action) {\r\n\t\t\tcase \"push\":\r\n\t\t\t\twindow.history.pushState.apply(window.history, args);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"replace\":\r\n\t\t\t\twindow.history.replaceState.apply(window.history, args);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n};\r\n", "import { Manager, ManagerItem, AdvancedManager } from \"./manager\";\r\nimport { equal, newURL } from \"./url\";\r\nimport { getConfig } from \"./config\";\r\nimport { Service } from \"./service\";\r\n\r\nexport interface IPage extends ManagerItem {\r\n    dom: Document,\r\n    wrapper: HTMLElement,\r\n    title: string,\r\n    head: Element,\r\n    body: Element,\r\n    url: URL,\r\n    data: string,\r\n    wrapperAttr: string,\r\n\r\n    build(): any,\r\n    install(): void,\r\n    uninstall(): any,\r\n}\r\n\r\n/**\r\n * Parses strings to DOM\r\n */\r\nexport const PARSER: DOMParser = new DOMParser();\r\n\r\n/** A page represents the DOM elements that create each page */\r\nexport class Page extends ManagerItem implements IPage {\r\n    /** Holds the DOM of the current page */\r\n    public dom: Document;\r\n\r\n    /** Holds the wrapper element to be swapped out of each Page */\r\n    public wrapper: HTMLElement;\r\n\r\n    /** Holds the title of each page */\r\n    public title: string;\r\n\r\n    /** Holds the head element of each page */\r\n    public head: Element;\r\n\r\n    /** Holds the body element of each page */\r\n    public body: Element;\r\n\r\n    /** The URL of the current page */\r\n    public url: URL;\r\n\r\n    /** The payload of a page request */\r\n    public data: string;\r\n\r\n    /** Attr that identifies the wrapper */\r\n    public wrapperAttr: string;\r\n\r\n    constructor(url: URL = newURL(), dom: string | Document = document) {\r\n        super();\r\n        this.url = url;\r\n\r\n        if (typeof dom === \"string\") {\r\n            this.data = dom;\r\n        } else this.dom = dom || document;\r\n    }\r\n\r\n    /** Builds the page's dom, and sets the title, head, body, and wrapper properties of the Page class */\r\n    public build() {\r\n        if (!(this.dom instanceof Node)) {\r\n            this.dom = PARSER.parseFromString(this.data, \"text/html\");\r\n        }\r\n\r\n        if (!(this.body instanceof Node)) {\r\n            let { title, head, body } = this.dom;\r\n            this.title = title;\r\n            this.head = head;\r\n            this.body = body;\r\n            this.wrapper = this.body.querySelector(this.wrapperAttr);\r\n        }\r\n    }\r\n\r\n    public install() {\r\n        this.wrapperAttr = getConfig(this.config, \"wrapperAttr\");\r\n    }\r\n\r\n    public uninstall() {\r\n        this.url = undefined;\r\n        this.title = undefined;\r\n        this.head = undefined;\r\n        this.body = undefined;\r\n        this.dom = undefined;\r\n        this.wrapper = undefined;\r\n        this.data = undefined;\r\n        this.wrapperAttr = undefined;\r\n    }\r\n}\r\n\r\nexport interface IPageManager extends Service {\r\n    loading: Manager<string, Promise<string>>,\r\n    maxPages: number,\r\n    pages: AdvancedManager<string, Page>;\r\n\r\n    install(): any,\r\n\r\n    get(key): Page,\r\n    add(value): PageManager,\r\n    set(key, value): PageManager,\r\n    remove(key): PageManager,\r\n    has(key): boolean,\r\n    clear(): PageManager,\r\n    size: number,\r\n    keys(): any[],\r\n\r\n    load(_url: URL | string): Promise<Page>,\r\n    request(url: string): Promise<string>,\r\n}\r\n\r\n/** Controls which page to load */\r\nexport class PageManager extends Service implements IPageManager {\r\n    /** Stores all fetch requests that are currently loading */\r\n    public loading: Manager<string, Promise<string>> = new Manager();\r\n    public maxPages: number;\r\n\r\n    pages: AdvancedManager<string, Page>;\r\n\r\n    /** Instantiate pages, and add the current page to pages */\r\n    install() {\r\n        this.pages = new AdvancedManager(this.app);\r\n        this.maxPages = this.config.maxPages ?? 5;\r\n\r\n        let URLString = newURL().pathname;\r\n        this.set(URLString, new Page());\r\n        URLString = undefined;\r\n    }\r\n\r\n    get(key) { return this.pages.get(key); }\r\n    add(value) { this.pages.add(value); return this; }\r\n    set(key, value) { this.pages.set(key, value); return this; }\r\n    remove(key) { this.pages.remove(key); return this; }\r\n    has(key) { return this.pages.has(key); }\r\n    clear() { this.pages.clear(); return this; }\r\n    get size() { return this.pages.size; }\r\n    keys() { return this.pages.keys(); }\r\n\r\n    /** Load from cache or by requesting URL via a fetch request, avoid requesting for the same thing twice by storing the fetch request in \"this.loading\" */\r\n    public async load(_url: URL | string = newURL()): Promise<Page> {\r\n        let url: URL = newURL(_url);\r\n        let urlString: string = url.pathname;\r\n        let page: Page, request: Promise<string>;\r\n        if (this.has(urlString)) {\r\n            page = this.get(urlString);\r\n            return Promise.resolve(page);\r\n        }\r\n\r\n        if (!this.loading.has(urlString)) {\r\n            request = this.request(urlString);\r\n            this.loading.set(urlString, request);\r\n        } else request = this.loading.get(urlString);\r\n\r\n        let response = await request;\r\n        this.loading.remove(urlString);\r\n\r\n        page = new Page(url, response);\r\n        this.set(urlString, page);\r\n\r\n        if (this.size > this.maxPages) {\r\n            let currentUrl = newURL();\r\n            let keys = this.keys();\r\n            let first = equal(currentUrl, keys[0]) ? keys[1] : keys[0];\r\n            let page = this.get(first);\r\n            page.unregister();\r\n            page = undefined;\r\n            keys = undefined;\r\n            currentUrl = undefined;\r\n            first = undefined;\r\n        }\r\n        return page;\r\n    }\r\n\r\n    /** Starts a fetch request */\r\n    public async request(url: string): Promise<string> {\r\n        const headers = new Headers(getConfig(this.config, \"headers\"));\r\n        const timeout = window.setTimeout(() => {\r\n            window.clearTimeout(timeout);\r\n            throw \"Request Timed Out!\";\r\n        }, getConfig(this.config, \"timeout\"));\r\n\r\n        try {\r\n            let response = await fetch(url, {\r\n                mode: 'same-origin',\r\n                method: \"GET\",\r\n                headers,\r\n                cache: \"default\",\r\n                credentials: \"same-origin\",\r\n            });\r\n\r\n            window.clearTimeout(timeout);\r\n            if (response.status >= 200 && response.status < 300) {\r\n                return await response.text();\r\n            }\r\n\r\n            const err = new Error(response.statusText || \"\" + response.status);\r\n            throw err;\r\n        } catch (err) {\r\n            window.clearTimeout(timeout);\r\n            throw err;\r\n        }\r\n    }\r\n}\r\n", "import { Manager, methodCall } from \"@okikio/manager\";\r\n\r\nexport type ListenerCallback = ((...args: any) => void);\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/** Represents a new event listener consisting of properties like: callback, scope, name */\r\nexport const newListener = ({\r\n    callback = () => { },\r\n    scope = null,\r\n    name = \"event\",\r\n}: IListener): IListener => ({ callback, scope, name });\r\n\r\n/** Represents a new event  */\r\nexport class Event extends Manager<number, IListener> {\r\n    /** The name of the event */\r\n    public name: string;\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An Event Emitter\r\n * */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /** Gets event, if event doesn't exist create a new one */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /** Creates a listener and adds it to an event */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(newListener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n    /** Adds a listener to a given event */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Removes a listener from an event */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.get(name);\r\n        if (event instanceof Event && callback) {\r\n            let listener = newListener({ name, callback, scope });\r\n\r\n            event.forEach((value: IListener, i: number) => {\r\n                if (\r\n                    value.callback === listener.callback &&\r\n                    value.scope === listener.scope\r\n                ) {\r\n                    return event.remove(i);\r\n                }\r\n            });\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /** Remove a listener from a given event, or just completely remove an event */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            if (typeof _callback === \"function\") {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.remove(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Call all listeners within an event */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let _event: Event = this.get(event);\r\n\r\n            if (_event instanceof Event) {\r\n                _event.forEach((listener: IListener) => {\r\n                    let { callback, scope } = listener;\r\n                    callback.apply(scope, args);\r\n                });\r\n            }\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Clears events and event listeners */\r\n    public clear() {\r\n        methodCall(this, \"clear\");\r\n        super.clear();\r\n        return this;\r\n    }\r\n}\r\n\r\nexport default EventEmitter;\r\n", "import { Manager } from \"./manager\";\r\nimport { ICoords, newCoords, Trigger } from \"./history\";\r\nimport { IPage } from \"./page\";\r\nimport { getConfig } from \"./config\";\r\nimport { Service } from \"./service\";\r\nimport { newURL } from \"./url\";\r\n\r\n/**\r\n * The async function type, allows for smooth transition between Promises\r\n */\r\nexport type asyncFn = (err?: any, value?: any) => void;\r\nexport interface ITransition {\r\n    oldPage?: IPage;\r\n    newPage?: IPage;\r\n    trigger?: Trigger;\r\n    scroll?: { x: number; y: number };\r\n    scrollable?: boolean;\r\n    in: (data: ITransitionData) => any;\r\n    out: (data: ITransitionData) => any;\r\n    [key: string]: any;\r\n}\r\nexport interface ITransitionData {\r\n    from?: IPage;\r\n    to?: IPage;\r\n    trigger?: Trigger;\r\n    scroll?: ICoords;\r\n    done: asyncFn;\r\n}\r\nexport interface ITransitionManager extends Service {\r\n    transitions: Manager<string, ITransition>,\r\n\r\n    get(key: string): ITransition,\r\n    set(key: string, value: ITransition): TransitionManager,\r\n    add(value: ITransition): TransitionManager,\r\n    has(key: string): boolean,\r\n\r\n    boot(): any,\r\n    animate(name: string, data: any): Promise<ITransition>,\r\n}\r\n\r\n\r\n/** Auto scrolls to an elements position if the element has an hash */\r\nexport const hashAction = (coords?: ICoords, hash: string = window.location.hash) => {\r\n    try {\r\n        let _hash = hash[0] == \"#\" ? hash : newURL(hash).hash;\r\n        if (_hash.length > 1) {\r\n            let el = document.getElementById(_hash.slice(1)) as HTMLElement;\r\n\r\n            if (el) {\r\n                return newCoords(el.offsetLeft, el.offsetTop);\r\n            }\r\n        }\r\n    } catch (e) {\r\n        console.warn(\"[hashAction] error\", e);\r\n    }\r\n\r\n    return coords ?? newCoords(0, 0);\r\n};\r\n\r\n// The Default Transition\r\nconst Default: ITransition = {\r\n    name: \"default\",\r\n    scrollable: true,\r\n\r\n    out({ done }: ITransitionData) {\r\n        done();\r\n    },\r\n    in({ scroll, done }: ITransitionData) {\r\n        window.scroll(scroll.x, scroll.y);\r\n        done();\r\n    }\r\n};\r\n\r\n/** Controls which Transition between pages to use */\r\nexport class TransitionManager extends Service implements ITransitionManager {\r\n    transitions: Manager<string, ITransition>;\r\n    private _arg: Array<[string, ITransition]>;\r\n    constructor(transitions?: Array<[string, ITransition]>) {\r\n        super();\r\n        this._arg = transitions;\r\n    }\r\n\r\n    /** On Service install set Config */\r\n    public install() {\r\n        super.install();\r\n\r\n        let transitions = this._arg && this._arg.length ? this._arg : (getConfig(this.config, \"transitions\") ?? []);\r\n\r\n        // Manager like Maps use the most recent [key, value] Array it knows, replacing the default transition\r\n        // With any other transitions called [\"default\", ...]\r\n        transitions = [[\"default\", Default]].concat(transitions);\r\n        this.transitions = new Manager(transitions);\r\n    }\r\n\r\n    get(key: string) { return this.transitions.get(key); }\r\n    set(key: string, value: ITransition) { this.transitions.set(key, value); return this; }\r\n    add(value: ITransition) { this.transitions.add(value); return this; }\r\n    has(key: string) { return this.transitions.has(key); }\r\n\r\n    /** Starts a transition */\r\n    public async animate(name: string, data: any): Promise<ITransition> {\r\n        let transition: ITransition = this.transitions.get(name);\r\n        let scroll = data.scroll;\r\n        let ignoreHashAction = data.ignoreHashAction;\r\n        if (!(\"wrapper\" in data.oldPage) || !(\"wrapper\" in data.newPage))\r\n            throw `[Page] either oldPage or newPage aren't instances of the Page Class.\\n ${{\r\n                newPage: data.newPage,\r\n                oldPage: data.oldPage,\r\n            }}`;\r\n\r\n        // Replace the title\r\n        document.title = `` + data.newPage.title;\r\n\r\n        let fromWrapper = data.oldPage.wrapper;\r\n        let toWrapper = data.newPage.wrapper;\r\n\r\n        if (!(fromWrapper instanceof Node) || !(toWrapper instanceof Node))\r\n            throw `[Wrapper] the wrapper from the ${!(toWrapper instanceof Node) ? \"next\" : \"current\"\r\n            } page cannot be found. The wrapper must be an element that has the attribute ${getConfig(this.config,\r\n                \"wrapperAttr\"\r\n            )}.`;\r\n\r\n        // Give the Transition all the background data it may require\r\n        transition.init && transition?.init(data);\r\n\r\n        this.emitter.emit(\"BEFORE_TRANSITION_OUT\");\r\n\r\n        // Start the out point of the Transition\r\n        if (transition.out) {\r\n            await new Promise((done) => {\r\n                let outMethod: Promise<any> = transition.out.call(transition, {\r\n                    ...data,\r\n                    from: data.oldPage,\r\n                    trigger: data.trigger,\r\n                    done,\r\n                });\r\n\r\n                outMethod?.then(done);\r\n            });\r\n        }\r\n\r\n        this.emitter.emit(\"AFTER_TRANSITION_OUT\");\r\n\r\n        // Add the new wrapper before the old one\r\n        await new Promise<void>((done) => {\r\n            fromWrapper.insertAdjacentElement(\"beforebegin\", toWrapper);\r\n            this.emitter.emit(\"CONTENT_INSERT\");\r\n\r\n            if (!ignoreHashAction && !/back|popstate|forward/.test(data.trigger as string)) {\r\n                scroll = hashAction(scroll);\r\n            }\r\n            done();\r\n        });\r\n\r\n        // Replace the old wrapper with the new one\r\n        await new Promise<void>((done) => {\r\n            fromWrapper.remove();\r\n            fromWrapper = undefined;\r\n            toWrapper = undefined;\r\n            this.emitter.emit(\"CONTENT_REPLACED\");\r\n            done();\r\n        });\r\n\r\n        this.emitter.emit(\"BEFORE_TRANSITION_IN\");\r\n\r\n        // Start the in point of the Transition (only the in method has access to the hashAction's scroll position)\r\n        if (transition.in) {\r\n            await new Promise(async (done) => {\r\n                let inMethod: Promise<any> = transition.in.call(transition, {\r\n                    ...data,\r\n                    from: data.oldPage,\r\n                    to: data.newPage,\r\n                    trigger: data.trigger,\r\n                    scroll,\r\n                    done,\r\n                });\r\n\r\n                inMethod?.then(done);\r\n            });\r\n        }\r\n\r\n        this.emitter.emit(\"AFTER_TRANSITION_IN\");\r\n        return transition;\r\n    }\r\n}\r\n", "import { EventEmitter, ListenerCallback, EventInput } from \"./emitter\";\r\nimport { ServiceManager, Service } from \"./service\";\r\nimport { newConfig, ICONFIG } from \"./config\";\r\n\r\nexport interface IApp {\r\n    services: ServiceManager,\r\n    emitter: EventEmitter,\r\n    config: ICONFIG,\r\n    register(config: ICONFIG): App,\r\n    get(key: string): Service,\r\n    set(key: string, service: Service): App,\r\n    add(value: Service): App,\r\n    boot(): App,\r\n    stop(): App,\r\n    on(events: EventInput, callback?: ListenerCallback): App,\r\n    off(events: EventInput, callback?: ListenerCallback): App,\r\n    emit(events: string | any[], ...args: any): App,\r\n}\r\n\r\n/** The App class starts the entire process, it controls all managers and all services */\r\nexport class App implements IApp {\r\n    /** An instance of the ServiceManager */\r\n    public services: ServiceManager;\r\n\r\n    /** An instance of an EventEmitter */\r\n    public emitter: EventEmitter;\r\n\r\n    /** The current Configuration's for the App */\r\n    public config: ICONFIG;\r\n    constructor(config: object = {}) {\r\n        this.register(config);\r\n    }\r\n\r\n    /** Create new instances of the ServiceManager, EventEmitter and the configurations */\r\n    public register(config: ICONFIG = {}): App {\r\n        this.config = newConfig(config);\r\n        this.emitter = new EventEmitter();\r\n        this.services = new ServiceManager(this);\r\n\r\n        let handler = (() => {\r\n            document.removeEventListener(\"DOMContentLoaded\", handler);\r\n            window.removeEventListener(\"load\", handler);\r\n            this.emitter.emit(\"READY ready\");\r\n        }).bind(this);\r\n\r\n        document.addEventListener(\"DOMContentLoaded\", handler);\r\n        window.addEventListener(\"load\", handler);\r\n        return this;\r\n    }\r\n\r\n    /** Shortcuts to adding, setting, and getting Services */\r\n    public get(key: string): Service {\r\n        return this.services.get(key);\r\n    }\r\n\r\n    public set(key: string, value: Service): App {\r\n        this.services.set(key, value);\r\n        return this;\r\n    }\r\n\r\n    public add(value: Service): App {\r\n        this.services.add(value);\r\n        return this;\r\n    }\r\n\r\n    /** Initialize and boot all Services */\r\n    public boot(): App {\r\n        this.services.init();\r\n        this.services.boot();\r\n        return this;\r\n    }\r\n\r\n    /** Stops all Services and clears the even emitter of all events and listeners */\r\n    public stop(): App {\r\n        this.services.stop();\r\n        this.emitter.clear();\r\n        return this;\r\n    }\r\n\r\n    /** Shortcuts to the App EventEmitter on, off, and emit methods */\r\n    public on(events: EventInput, callback?: ListenerCallback): App {\r\n        this.emitter.on(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    public off(events: EventInput, callback?: ListenerCallback): App {\r\n        this.emitter.off(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    public emit(events: string | any[], ...args: any): App {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n}\r\n", "import { newState, Trigger, newCoords, IHistoryItem, IHistoryManager } from \"./history\";\r\nimport { Service } from \"./service\";\r\nimport { IPage, IPageManager } from \"./page\";\r\nimport { newURL, getHashedPath, equal } from \"./url\";\r\nimport { getConfig } from \"./config\";\r\nimport { hashAction, ITransitionManager } from \"./transition\";\r\n\r\nexport type LinkEvent = MouseEvent | TouchEvent;\r\nexport type StateEvent = LinkEvent | PopStateEvent;\r\nexport type IgnoreURLsList = Array<RegExp | string>;\r\n/**\r\n * Creates a barbajs like PJAX Service, for the native framework\r\n * Based on barbajs and StartingBlocks\r\n */\r\nexport class PJAX extends Service {\r\n    /** URLs to ignore when prefetching */\r\n    public ignoreURLs: IgnoreURLsList;\r\n\r\n    /** Whether or not to disable prefetching */\r\n    public prefetchIgnore: boolean;\r\n\r\n    /** Current state of transitions */\r\n    public isTransitioning: boolean;\r\n\r\n    /** Ignore extra clicks of an anchor element if a transition has already started */\r\n    public stopOnTransitioning: boolean;\r\n\r\n    /** On page change (excluding popstate events) keep current scroll position */\r\n    public stickyScroll: boolean;\r\n\r\n    /** Force load a page if an error occurs */\r\n    public forceOnError: boolean;\r\n\r\n    /** Ignore hash action if set to true */\r\n    public ignoreHashAction: boolean;\r\n\r\n    public install() {\r\n        super.install();\r\n\r\n        this.ignoreURLs = getConfig(this.config, \"ignoreURLs\") ?? [];\r\n        this.prefetchIgnore = getConfig(this.config, \"prefetchIgnore\") ?? false;\r\n        this.stopOnTransitioning = getConfig(this.config, \"stopOnTransitioning\") ?? false;\r\n        this.stickyScroll = getConfig(this.config, \"stickyScroll\") ?? false;\r\n        this.forceOnError = getConfig(this.config, \"forceOnError\") ?? false;\r\n        this.ignoreHashAction = getConfig(this.config, \"ignoreHashAction\") ?? false\r\n    }\r\n\r\n    /** Sets the transition state to either true or false */\r\n    public transitionStart() {\r\n        this.isTransitioning = true;\r\n    }\r\n\r\n    public transitionStop() {\r\n        this.isTransitioning = false;\r\n    }\r\n\r\n    public init() {\r\n        /**\r\n         * Bind the event listeners to the PJAX class\r\n         *\r\n         * @memberof PJAX\r\n         */\r\n        this.onHover = this.onHover.bind(this);\r\n        this.onClick = this.onClick.bind(this);\r\n        this.onStateChange = this.onStateChange.bind(this);\r\n    }\r\n\r\n    /** Starts the PJAX Service */\r\n    public boot() {\r\n        if (\"scrollRestoration\" in window.history) {\r\n            // Back off, browser, I got this...\r\n            window.history.scrollRestoration = \"manual\";\r\n        }\r\n\r\n        super.boot();\r\n    }\r\n\r\n    /** Gets the transition to use for a certain anchor */\r\n    public getTransitionName(el: HTMLAnchorElement): string | null {\r\n        if (!el || !el.getAttribute) return null;\r\n        let transitionAttr = el.getAttribute(\r\n            getConfig(this.config, \"transitionAttr\", false)\r\n        );\r\n\r\n        if (typeof transitionAttr === \"string\") return transitionAttr;\r\n        return null;\r\n    }\r\n\r\n    /** Checks to see if the anchor is valid */\r\n    public validLink(\r\n        el: HTMLAnchorElement,\r\n        event: LinkEvent | KeyboardEvent,\r\n        href: string\r\n    ): boolean {\r\n        let pushStateSupport = !window.history.pushState;\r\n        let exists = !el || !href;\r\n        let eventMutate =\r\n            (event as KeyboardEvent).metaKey ||\r\n            (event as KeyboardEvent).ctrlKey ||\r\n            (event as KeyboardEvent).shiftKey ||\r\n            (event as KeyboardEvent).altKey;\r\n        let newTab =\r\n            el.hasAttribute(\"target\") &&\r\n            (el as HTMLAnchorElement).target === \"_blank\";\r\n        let crossOrigin =\r\n            (el as HTMLAnchorElement).protocol !== location.protocol ||\r\n            (el as HTMLAnchorElement).hostname !== location.hostname;\r\n        let download = typeof el.getAttribute(\"download\") === \"string\";\r\n        let preventSelf = el.matches(getConfig(this.config, \"preventSelfAttr\"));\r\n        let preventAll = Boolean(\r\n            el.closest(getConfig(this.config, \"preventAllAttr\"))\r\n        );\r\n        let sameURL = getHashedPath(newURL()) === getHashedPath(newURL(href));\r\n        return !(\r\n            exists ||\r\n            pushStateSupport ||\r\n            eventMutate ||\r\n            newTab ||\r\n            crossOrigin ||\r\n            download ||\r\n            preventSelf ||\r\n            preventAll ||\r\n            sameURL\r\n        );\r\n    }\r\n\r\n    /** Returns the href of an Anchor element */\r\n    public getHref(el: HTMLAnchorElement): string | null {\r\n        if (\r\n            el &&\r\n            el.tagName &&\r\n            el.tagName.toLowerCase() === \"a\" &&\r\n            typeof el.href === \"string\"\r\n        )\r\n            return el.href;\r\n        return null;\r\n    }\r\n\r\n    /** Check if event target is a valid anchor with an href, if so, return the anchor */\r\n    public getLink(event: LinkEvent): HTMLAnchorElement {\r\n        let el = event.target as HTMLAnchorElement;\r\n        let href: string = this.getHref(el);\r\n\r\n        while (el && !href) {\r\n            el = (el as HTMLElement).parentNode as HTMLAnchorElement;\r\n            href = this.getHref(el);\r\n        }\r\n\r\n        // Check for a valid link\r\n        if (!el || !this.validLink(el, event, href)) return;\r\n        return el;\r\n    }\r\n\r\n    /** When an element is clicked, get valid anchor element, go for a transition */\r\n    public onClick(event: LinkEvent) {\r\n        let el = this.getLink(event);\r\n        if (!el) return;\r\n\r\n        if (this.isTransitioning && this.stopOnTransitioning) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            return;\r\n        }\r\n\r\n        let href = this.getHref(el);\r\n        this.emitter.emit(\"ANCHOR_CLICK CLICK\", event);\r\n        this.go({ href, trigger: el, event });\r\n    }\r\n\r\n    /** Returns the direction of the State change as a String, either the Back button or the Forward button */\r\n    public getDirection(value: number): Trigger {\r\n        if (Math.abs(value) > 1) {\r\n            // Ex 6-0 > 0 -> forward, 0-6 < 0 -> back\r\n            return value > 0 ? \"forward\" : \"back\";\r\n        } else {\r\n            if (value === 0) {\r\n                return \"popstate\";\r\n            } else {\r\n                // Ex 6-5 > 0 -> back, 5-6 < 0 -> forward\r\n                return value > 0 ? \"back\" : \"forward\";\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Force a page to go to a certain URL */\r\n    public force(href: string): void {\r\n        window.location.assign(href);\r\n    }\r\n\r\n    /**\r\n     * If transition is running force load page.\r\n     * Stop if currentURL is the same as new url.\r\n     * On state change, change the current state history, to reflect the direction of said state change\r\n     * Load page and page transition.\r\n     */\r\n    public go({\r\n        href,\r\n        trigger = \"HistoryManager\",\r\n        event,\r\n    }: {\r\n        href: string;\r\n        trigger?: Trigger;\r\n        event?: StateEvent;\r\n    }): Promise<void> {\r\n        // If transition is already running and the go method is called again, force load page\r\n        if (this.isTransitioning && this.stopOnTransitioning ||\r\n            !(this.manager.has(\"TransitionManager\") &&\r\n                this.manager.has(\"HistoryManager\") &&\r\n                this.manager.has(\"PageManager\"))) {\r\n            this.force(href);\r\n            return;\r\n        }\r\n\r\n        const history = this.manager.get(\"HistoryManager\") as IHistoryManager;\r\n        let scroll = newCoords(0, 0);\r\n        let currentState = history.current;\r\n        let currentURL = currentState.url;\r\n        if (equal(currentURL, href)) {\r\n            return;\r\n        }\r\n\r\n        let transitionName: string;\r\n        if (event && (event as PopStateEvent).state) {\r\n            this.emitter.emit(\"POPSTATE\", event);\r\n\r\n            // If popstate, get back/forward direction.\r\n            let { state }: { state: IHistoryItem } = event as PopStateEvent;\r\n            let { index } = state;\r\n            let currentIndex = currentState.index;\r\n            let difference = currentIndex - index;\r\n\r\n            let _state = history.get(history.pointer);\r\n            transitionName = _state.transition;\r\n            scroll = _state.data.scroll;\r\n\r\n            history.replace(state.states);\r\n            history.pointer = index;\r\n\r\n            trigger = this.getDirection(difference);\r\n\r\n            // Based on the direction of the state change either remove or add a state\r\n            this.emitter.emit(trigger === \"back\" ? `POPSTATE_BACK` : `POPSTATE_FORWARD`, event);\r\n        } else {\r\n            // Add new state\r\n            transitionName = this.getTransitionName(trigger as HTMLAnchorElement);\r\n\r\n            scroll = newCoords();\r\n            let state = newState({\r\n                url: href,\r\n                transition: transitionName,\r\n                data: { scroll },\r\n            });\r\n\r\n            !this.stickyScroll && (scroll = newCoords(0, 0));\r\n\r\n            history.add(state);\r\n            this.emitter.emit(\"HISTORY_NEW_ITEM\", event);\r\n        }\r\n\r\n        if (event) {\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n\r\n        this.emitter.emit(\"GO\", event);\r\n        return this.load({\r\n            oldHref: currentURL,\r\n            href,\r\n            trigger,\r\n            transitionName,\r\n            scroll,\r\n        });\r\n    }\r\n\r\n    /** Load the new Page as well as a Transition; starts the Transition */\r\n    public async load({\r\n        oldHref,\r\n        href,\r\n        trigger,\r\n        transitionName = \"default\",\r\n        scroll = { x: 0, y: 0 },\r\n    }: {\r\n        oldHref: string;\r\n        href: string;\r\n        trigger: Trigger;\r\n        transitionName?: string;\r\n        scroll: { x: number; y: number };\r\n    }): Promise<any> {\r\n        try {\r\n            const pages = this.manager.get(\"PageManager\") as IPageManager;\r\n            let newPage: IPage, oldPage: IPage;\r\n\r\n            this.emitter.emit(\"NAVIGATION_START\", {\r\n                oldHref,\r\n                href,\r\n                trigger,\r\n                transitionName,\r\n            });\r\n\r\n            // Load & Build both the old and new pages\r\n            try {\r\n                this.transitionStart();\r\n                oldPage = await pages.load(oldHref);\r\n                !(oldPage.dom instanceof Element) && oldPage.build();\r\n\r\n                this.emitter.emit(\"PAGE_LOADING\", { href, oldPage, trigger });\r\n                newPage = await pages.load(href);\r\n                await newPage.build();\r\n                this.emitter.emit(\"PAGE_LOAD_COMPLETE\", {\r\n                    newPage,\r\n                    oldPage,\r\n                    trigger,\r\n                });\r\n            } catch (err) {\r\n                throw `[PJAX] page load error: ${err}`;\r\n            }\r\n\r\n            // --\r\n            // --\r\n\r\n            // Start Transition\r\n            try {\r\n                const TransitionManager = this.manager.get(\"TransitionManager\") as ITransitionManager;\r\n                this.emitter.emit(\"TRANSITION_START\", transitionName);\r\n\r\n                let transition = await TransitionManager.animate(TransitionManager.has(transitionName) ? transitionName : \"default\", {\r\n                    oldPage,\r\n                    newPage,\r\n                    trigger,\r\n                    scroll,\r\n                    ignoreHashAction: this.ignoreHashAction\r\n                });\r\n\r\n                if (!transition.scrollable) {\r\n                    if (!this.ignoreHashAction && !/back|popstate|forward/.test(trigger as string)) scroll = hashAction(scroll);\r\n                    window.scroll(scroll.x, scroll.y);\r\n                }\r\n\r\n                this.emitter.emit(\"TRANSITION_END\", { transition });\r\n            } catch (err) {\r\n                throw `[PJAX] transition error: ${err}`;\r\n            }\r\n\r\n            this.emitter.emit(\"NAVIGATION_END\", {\r\n                oldPage,\r\n                newPage,\r\n                trigger,\r\n                transitionName,\r\n            });\r\n        } catch (err) {\r\n            if (this.forceOnError) this.force(href);\r\n            else console.warn(err);\r\n        } finally {\r\n            this.transitionStop(); // Sets isTransitioning to false\r\n        }\r\n    }\r\n\r\n    /** Check to see if the URL is to be ignored, uses either RegExp of Strings to check */\r\n    public ignoredURL({ pathname }: URL): boolean {\r\n        return (\r\n            this.ignoreURLs.length &&\r\n            this.ignoreURLs.some((url) => {\r\n                return typeof url === \"string\"\r\n                    ? url === pathname\r\n                    : (url as RegExp).exec(pathname) !== null;\r\n            })\r\n        );\r\n    }\r\n\r\n    /** When you hover over an anchor, prefetch the event target's href */\r\n    public onHover(event: LinkEvent): Promise<void> {\r\n        let el = this.getLink(event);\r\n        if (!el || !this.manager.has(\"PageManager\")) return;\r\n\r\n        const pages = this.manager.get(\"PageManager\") as IPageManager;\r\n        let url = newURL(this.getHref(el));\r\n        let urlString: string = url.pathname;\r\n\r\n        // If Url is ignored or already in cache, don't do any think\r\n        if (this.ignoredURL(url) || pages.has(urlString)) return;\r\n        this.emitter.emit(\"ANCHOR_HOVER HOVER\", event);\r\n\r\n        try {\r\n            pages.load(url);\r\n        } catch (err) {\r\n            console.warn(\"[PJAX] prefetch error,\", err);\r\n        }\r\n    }\r\n\r\n    /** When History state changes, get url from State, go for a Transition. */\r\n    public onStateChange(event: PopStateEvent): void {\r\n        this.go({ href: window.location.href, trigger: \"popstate\", event });\r\n    }\r\n\r\n    /** Initialize DOM Events */\r\n    public initEvents() {\r\n        if (this.prefetchIgnore !== true) {\r\n            document.addEventListener(\"mouseover\", this.onHover);\r\n            document.addEventListener(\"touchstart\", this.onHover);\r\n        }\r\n\r\n        document.addEventListener(\"click\", this.onClick);\r\n        window.addEventListener(\"popstate\", this.onStateChange);\r\n    }\r\n\r\n    /** Stop DOM Events */\r\n    public stopEvents() {\r\n        if (this.prefetchIgnore !== true) {\r\n            document.removeEventListener(\"mouseover\", this.onHover);\r\n            document.removeEventListener(\"touchstart\", this.onHover);\r\n        }\r\n\r\n        document.removeEventListener(\"click\", this.onClick);\r\n        window.removeEventListener(\"popstate\", this.onStateChange);\r\n    }\r\n}\r\n", "import { Service } from \"./service\";\r\nimport { Manager } from \"./manager\";\r\nimport { newURL, getHashedPath } from \"./url\";\r\nimport { IHistoryManager } from \"./history\";\r\n\r\nexport type RouteMethod = (...args: any) => any;\r\nexport type RouteStyle = string | RegExp | boolean;\r\nexport interface IRouteToFrom {\r\n    to: RouteStyle,\r\n    from: RouteStyle\r\n}\r\nexport type RoutePath = IRouteToFrom | RouteStyle;\r\nexport interface IRoute {\r\n    path: RoutePath,\r\n    method: RouteMethod\r\n}\r\n\r\n/** Controls what happens when certain url paths match a set of criteria */\r\nexport class Router extends Service {\r\n    /** List of routes */\r\n    protected routes: Manager<IRouteToFrom, RouteMethod>;\r\n    constructor(routes: IRoute[] = []) {\r\n        super();\r\n        this.routes = new Manager();\r\n        for (let route of routes) {\r\n            this.add(route);\r\n        }\r\n    }\r\n\r\n    /** Add a new route to watch for */\r\n    public add({ path, method }: IRoute): Router {\r\n        let key = this.parse(path);\r\n        this.routes.set(key, method);\r\n        return this;\r\n    }\r\n\r\n    /** Convert strings into path match functions */\r\n    public parsePath(path: RouteStyle): RegExp | boolean {\r\n        if (typeof path === \"string\") return new RegExp(path, \"i\");\r\n        else if (path instanceof RegExp || typeof path === \"boolean\")\r\n            return path;\r\n        throw \"[Router] only regular expressions, strings and booleans are accepted as paths.\";\r\n    }\r\n\r\n    /** Determines if a strings counts has a path */\r\n    public isPath(input: RouteStyle): boolean {\r\n        return (\r\n            typeof input === \"string\" ||\r\n            input instanceof RegExp ||\r\n            typeof input === \"boolean\"\r\n        );\r\n    }\r\n\r\n    /** Parse the multiple different formats for paths, into a { from, to } object */\r\n    public parse(input: RoutePath): IRouteToFrom {\r\n        let route = input as IRouteToFrom;\r\n        let toFromPath: IRouteToFrom = {\r\n            from: /(.*)/g,\r\n            to: /(.*)/g,\r\n        };\r\n\r\n        if (this.isPath(input as RouteStyle))\r\n            toFromPath = {\r\n                from: true,\r\n                to: input as RouteStyle,\r\n            };\r\n        else if (this.isPath(route.from) && this.isPath(route.to as RouteStyle))\r\n            toFromPath = route;\r\n        else\r\n            throw \"[Router] path is neither a string, regular expression, or a { from, to } object.\";\r\n\r\n        let { from, to } = toFromPath;\r\n        return {\r\n            from: this.parsePath(from),\r\n            to: this.parsePath(to),\r\n        };\r\n    }\r\n\r\n    /** Test if route paths are true, if so run their methods */\r\n    public route() {\r\n        if (this.manager.has(\"HistoryManager\")) {\r\n            let history = this.manager.get(\"HistoryManager\") as IHistoryManager;\r\n            let from: string = getHashedPath(newURL((history.length > 1 ? history.previous : history.current).url));\r\n            let to: string = getHashedPath(newURL());\r\n\r\n            this.routes.forEach((method: RouteMethod, path: IRouteToFrom) => {\r\n                let fromRegExp = path.from as RegExp | boolean;\r\n                let toRegExp = path.to as RegExp | boolean;\r\n\r\n                if (\r\n                    typeof fromRegExp === \"boolean\" &&\r\n                    typeof toRegExp === \"boolean\"\r\n                ) {\r\n                    throw `[Router] path ({ from: ${fromRegExp}, to: ${toRegExp} }) is not valid, remember paths can only be strings, regular expressions, or a boolean; however, both the from and to paths cannot be both booleans.`;\r\n                }\r\n\r\n                let fromParam: RegExpExecArray | RegExp | boolean = fromRegExp;\r\n                let toParam: RegExpExecArray | RegExp | boolean = toRegExp;\r\n\r\n                if (fromRegExp instanceof RegExp && fromRegExp.test(from))\r\n                    fromParam = fromRegExp.exec(from);\r\n                if (toRegExp instanceof RegExp && toRegExp.test(to))\r\n                    toParam = toRegExp.exec(to);\r\n\r\n                if (\r\n                    (Array.isArray(toParam) && Array.isArray(fromParam)) ||\r\n                    (Array.isArray(toParam) &&\r\n                        typeof fromParam == \"boolean\" &&\r\n                        fromParam) ||\r\n                    (Array.isArray(fromParam) &&\r\n                        typeof toParam == \"boolean\" &&\r\n                        toParam)\r\n                )\r\n                    method({ from: fromParam, to: toParam, path: { from, to } });\r\n            });\r\n        } else {\r\n            console.warn(\"[Route] HistoryManager is missing.\");\r\n        }\r\n    }\r\n\r\n    /** Add listeners for PJAX Events */\r\n    public initEvents() {\r\n        this.emitter.on(\"READY\", this.route, this);\r\n        this.emitter.on(\"CONTENT_REPLACED\", this.route, this);\r\n    }\r\n\r\n    /** Remove listeners for PJAX Events */\r\n    public stopEvents() {\r\n        this.emitter.off(\"READY\", this.route, this);\r\n        this.emitter.off(\"CONTENT_REPLACED\", this.route, this);\r\n    }\r\n}\r\n", "import { EventEmitter, EventInput, ListenerCallback } from \"@okikio/emitter\";\r\nimport { Manager } from \"@okikio/manager\";\r\n\r\n// DOM\r\nexport type AnimationTarget = string | Node | NodeList | HTMLCollection | HTMLElement[] | AnimationTarget[];\r\nexport const getElements = (selector: string | Node): Node[] => {\r\n    return typeof selector === \"string\" ? Array.from(document.querySelectorAll(selector as string)) : [selector];\r\n};\r\n\r\nconst flatten = (arr: AnimationTarget[]) => [].concat(...arr);\r\nexport const getTargets = (targets: AnimationTarget): Node[] => {\r\n    if (Array.isArray(targets)) {\r\n        return flatten((targets as AnimationTarget[]).map(getTargets));\r\n    }\r\n    if (typeof targets == \"string\" || targets instanceof Node)\r\n        return getElements(targets);\r\n    if (targets instanceof NodeList || targets instanceof HTMLCollection)\r\n        return Array.from(targets);\r\n    return [];\r\n};\r\n\r\n// VALUES\r\nexport type closureArgs = [number, number, HTMLElement];\r\nexport type closure = ((index?: number, total?: number, element?: HTMLElement) => any) | any;\r\nexport const computeValue = (value: closure, args: closureArgs, context: AnimationOptions) => {\r\n    if (typeof value === \"function\") {\r\n        return value.apply(context, args);\r\n    } else { return value; }\r\n};\r\n\r\nexport const mapObject = (obj: object, args: closureArgs, options: AnimationOptions): any => {\r\n    let key: string, value: any, result = {};\r\n    let keys = Object.keys(obj);\r\n    for (let i = 0, len = keys.length; i < len; i++) {\r\n        key = keys[i];\r\n        value = obj[key];\r\n        result[key] = computeValue(value, args, options);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/** From: [https://easings.net] */\r\nexport const easings = {\r\n    \"in\": \"ease-in\",\r\n    \"out\": \"ease-out\",\r\n    \"in-out\": \"ease-in-out\",\r\n\r\n    // Sine\r\n    \"in-sine\": \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\r\n    \"out-sine\": \"cubic-bezier(0.39, 0.575, 0.565, 1)\",\r\n    \"in-out-sine\": \"cubic-bezier(0.445, 0.05, 0.55, 0.95)\",\r\n\r\n    // Quad\r\n    \"in-quad\": \"cubic-bezier(0.55, 0.085, 0.68, 0.53)\",\r\n    \"out-quad\": \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\r\n    \"in-out-quad\": \"cubic-bezier(0.455, 0.03, 0.515, 0.955)\",\r\n\r\n    // Cubic\r\n    \"in-cubic\": \"cubic-bezier(0.55, 0.055, 0.675, 0.19)\",\r\n    \"out-cubic\": \"cubic-bezier(0.215, 0.61, 0.355, 1)\",\r\n    \"in-out-cubic\": \"cubic-bezier(0.645, 0.045, 0.355, 1)\",\r\n\r\n    // Quart\r\n    \"in-quart\": \"cubic-bezier(0.895, 0.03, 0.685, 0.22)\",\r\n    \"out-quart\": \"cubic-bezier(0.165, 0.84, 0.44, 1)\",\r\n    \"in-out-quart\": \"cubic-bezier(0.77, 0, 0.175, 1)\",\r\n\r\n    // Quint\r\n    \"in-quint\": \"cubic-bezier(0.755, 0.05, 0.855, 0.06)\",\r\n    \"out-quint\": \"cubic-bezier(0.23, 1, 0.32, 1)\",\r\n    \"in-out-quint\": \"cubic-bezier(0.86, 0, 0.07, 1)\",\r\n\r\n    // Expo\r\n    \"in-expo\": \"cubic-bezier(0.95, 0.05, 0.795, 0.035)\",\r\n    \"out-expo\": \"cubic-bezier(0.19, 1, 0.22, 1)\",\r\n    \"in-out-expo\": \"cubic-bezier(1, 0, 0, 1)\",\r\n\r\n    // Circ\r\n    \"in-circ\": \"cubic-bezier(0.6, 0.04, 0.98, 0.335)\",\r\n    \"out-circ\": \"cubic-bezier(0.075, 0.82, 0.165, 1)\",\r\n    \"in-out-circ\": \"cubic-bezier(0.785, 0.135, 0.15, 0.86)\",\r\n\r\n    // Back\r\n    \"in-back\": \"cubic-bezier(0.6, -0.28, 0.735, 0.045)\",\r\n    \"out-back\": \"cubic-bezier(0.175, 0.885, 0.32, 1.275)\",\r\n    \"in-out-back\": \"cubic-bezier(0.68, -0.55, 0.265, 1.55)\"\r\n};\r\n\r\nexport const getEase = (ease: string) => {\r\n    return /^(in|out)/.test(ease) ? easings[ease] : ease;\r\n};\r\n\r\nexport interface AnimationOptions {\r\n    target?: AnimationTarget,\r\n\r\n    speed?: number,\r\n    autoplay?: boolean,\r\n    options?: AnimationOptions,\r\n    delay?: number | closure,\r\n    easing?: string | closure,\r\n    endDelay?: number | closure,\r\n    duration?: number | closure,\r\n    keyframes?: object[] | closure,\r\n    loop?: number | boolean | closure, // iterations: number,\r\n    onfinish?: (element?: HTMLElement, index?: number, total?: number, animation?: Animation) => any,\r\n    fillMode?: \"none\" | \"forwards\" | \"backwards\" | \"both\" | \"auto\" | closure,\r\n    direction?: \"normal\" | \"reverse\" | \"alternate\" | \"alternate-reverse\" | closure,\r\n    extend?: EffectTiming,\r\n    [property: string]: closure | boolean | object | string | string[] | number | null | (number | null)[] | undefined;\r\n};\r\n\r\nexport const DefaultAnimationOptions: AnimationOptions = {\r\n    keyframes: [],\r\n\r\n    loop: 1, // iterations: number,\r\n    delay: 0,\r\n    speed: 1,\r\n    endDelay: 0,\r\n    easing: \"ease\",\r\n    autoplay: true,\r\n    duration: 1000,\r\n    fillMode: \"auto\",\r\n    direction: \"normal\",\r\n    extend: {}\r\n};\r\n\r\nexport type AnimationEvents = \"update\" | \"play\" | \"pause\" | \"start\" | \"begin\" | \"complete\" | \"finish\" | \"error\" | \"stop\";\r\n\r\n/** You can check it out here: https://codepen.io/okikio/pen/qBbdGaW?editors=0011 */\r\nexport class Animate {\r\n    /**\r\n     * Stores the options for the current animation\r\n     */\r\n    public options: AnimationOptions = {};\r\n\r\n    /**\r\n     * The Array of Elements to Animate\r\n     */\r\n    public targets: Node[] = [];\r\n\r\n    /**\r\n     * The properties to animate\r\n     */\r\n    public properties: object = {};\r\n\r\n    /**\r\n     * A Manager of Animations\r\n     */\r\n    public animations: Manager<HTMLElement, Animation> = new Manager();\r\n\r\n    /**\r\n     * The total duration of all Animation's\r\n     */\r\n    public totalDuration: number = 0;\r\n\r\n    /**\r\n     * The smallest delay out of all Animation's\r\n     */\r\n    public minDelay: number = 0;\r\n\r\n    /**\r\n     * The options for individual animations\r\n     */\r\n    public computedOptions: Manager<Animation, AnimationOptions> = new Manager();\r\n\r\n    /**\r\n     * The Element the main animation uses\r\n     */\r\n    public mainElement: HTMLElement;\r\n\r\n    /**\r\n     * Stores an animation that runs on the total duration of the all other Animations, and as such it's the main Animation\r\n     */\r\n    public mainAnimation: Animation;\r\n\r\n    /**\r\n     * Stores request frame calls\r\n     */\r\n    public animationFrame: number;\r\n\r\n    /**\r\n     * An event emitter\r\n     */\r\n    public emitter: EventEmitter = new EventEmitter();\r\n\r\n    /**\r\n     * Returns a promise that is fulfilled when the mainAnimation is finished\r\n     */\r\n    public promise: Promise<AnimationOptions>;\r\n    constructor(options: AnimationOptions = {}) {\r\n        try {\r\n            let { options: animation, ...rest } = options;\r\n            let oldOptions = animation instanceof Animate ? animation.getOptions() : (Array.isArray(animation) ? animation?.[0]?.getOptions() : animation);\r\n            this.options = Object.assign({}, DefaultAnimationOptions, oldOptions, rest);\r\n            this.loop = this.loop.bind(this);\r\n\r\n            let {\r\n                loop,\r\n                delay,\r\n                speed,\r\n                easing,\r\n                endDelay,\r\n                duration,\r\n                direction,\r\n                fillMode,\r\n                onfinish,\r\n                target,\r\n                keyframes,\r\n                autoplay,\r\n                extend,\r\n                ...properties\r\n            } = this.options;\r\n\r\n            this.mainElement = document.createElement(\"div\");\r\n            this.targets = getTargets(target);\r\n            this.properties = properties;\r\n\r\n            let delays = [];\r\n            let len = this.targets.length;\r\n            let animationKeyframe: Keyframe[] | PropertyIndexedKeyframes;\r\n            for (let i = 0; i < len; i++) {\r\n                let target = this.targets[i] as HTMLElement;\r\n                let animationOptions: AnimationOptions = {\r\n                    easing: typeof easing == \"string\" ? getEase(easing) : easing,\r\n                    iterations: loop === true ? Infinity : (loop as number),\r\n                    direction,\r\n                    endDelay,\r\n                    duration,\r\n                    delay,\r\n                    fill: fillMode,\r\n                    ...extend\r\n                };\r\n\r\n                // Accept keyframes as a keyframes Object, or a method,\r\n                // if there are no animations in the keyframes array,\r\n                // uses css properties from the options object\r\n                let arrKeyframes = computeValue((keyframes as Keyframe[]), [i, len, target], animationOptions);\r\n                animationKeyframe = arrKeyframes.length ? arrKeyframes :\r\n                    (this.properties as PropertyIndexedKeyframes);\r\n\r\n                // Allows the use of functions as the values, for both the keyframes and the animation object\r\n                // It adds the capability of advanced stagger animation, similar to the anime js stagger functions\r\n                animationOptions = mapObject(animationOptions, [i, len, target], animationOptions);\r\n                if (!(arrKeyframes.length > 0))\r\n                    animationKeyframe = mapObject(animationKeyframe, [i, len, target], animationOptions);\r\n\r\n                // Set the Animate classes duration to be the Animation with the largest totalDuration\r\n                let tempDurations = animationOptions.delay +\r\n                    (animationOptions.duration * animationOptions.iterations) +\r\n                    animationOptions.endDelay;\r\n                if (this.totalDuration < tempDurations) this.totalDuration = tempDurations;\r\n\r\n                // Add animation to the Animations Set\r\n                let animation = target.animate(animationKeyframe, animationOptions);\r\n\r\n                // Support for on finish\r\n                animation.onfinish = () => {\r\n                    typeof onfinish == \"function\" && onfinish.call(this, target, i, len, animation);\r\n                    this.emit(\"finish\", target, i, len, animation);\r\n                };\r\n\r\n                // The calculated options for each individual option\r\n                this.computedOptions.set(animation, animationOptions);\r\n                this.animations.set(target, animation);\r\n                delays.push(animationOptions.delay);\r\n            }\r\n\r\n            this.mainAnimation = this.mainElement.animate([\r\n                { opacity: \"0\" },\r\n                { opacity: \"1\" }\r\n            ], {\r\n                // Why waste performance on an animation no one can see?\r\n                duration: this.totalDuration,\r\n                easing: \"linear\"\r\n            });\r\n\r\n            this.minDelay = Math.min(...delays);\r\n            this.setSpeed(speed);\r\n            if (autoplay) this.play();\r\n            else this.pause();\r\n\r\n            this.promise = this.newPromise();\r\n            this.mainAnimation.onfinish = () => {\r\n                this.emit(\"complete\", this);\r\n                window.cancelAnimationFrame(this.animationFrame);\r\n            };\r\n        } catch (err) {\r\n            this.emit(\"error\", err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a new Promise that is resolve when this.finish is called\r\n     */\r\n    public newPromise(): Promise<AnimationOptions> {\r\n        return new Promise((resolve, reject) => {\r\n            /*\r\n                Note that the `this` keyword is in an Array when it is resolved,\r\n                this is due to Promises not wanting to resolve references,\r\n                so, you can't resolve `this` directly, so, I chose to resolve `this` in an\r\n                Array\r\n            */\r\n            this.on(\"complete\", () => resolve([this]));\r\n            this.on(\"error\", err => reject(err));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fulfills the this.promise Promise\r\n     */\r\n    public then(\r\n        onFulfilled?: (value?: any) => any,\r\n        onRejected?: (reason?: any) => any\r\n    ): Animate {\r\n        onFulfilled = onFulfilled?.bind(this);\r\n        onRejected = onRejected?.bind(this);\r\n        this.promise.then(onFulfilled, onRejected);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Catches error that occur in the this.promise Promise\r\n     */\r\n    public catch(onRejected: (reason?: any) => any): Animate {\r\n        onRejected = onRejected?.bind(this);\r\n        this.promise.catch(onRejected);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * If you don't care if the this.promise Promise has either been rejected or resolved\r\n     */\r\n    public finally(onFinally: () => any): Animate {\r\n        onFinally = onFinally?.bind(this);\r\n        this.promise.finally(onFinally);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Represents an Animation Frame Loop\r\n     */\r\n    public loop(): void {\r\n        this.animationFrame = window.requestAnimationFrame(this.loop);\r\n        this.emit(\"update\", this.getProgress(), this);\r\n    }\r\n\r\n    /**\r\n     * Calls a method that affects all animations including the mainAnimation; the method only allows the animation parameter\r\n    */\r\n    public all(method: (animation: Animation) => void) {\r\n        method(this.mainAnimation);\r\n        this.animations.forEach(animation => method(animation));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register the begin event\r\n     */\r\n    protected beginEvent() {\r\n        if (this.getProgress() == 0) {\r\n            let timer: number | void = window.setTimeout(() => {\r\n                this.emit(\"begin\", this);\r\n                timer = window.clearTimeout(timer as number);\r\n            }, this.minDelay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Play Animation\r\n     */\r\n    public play(): Animate {\r\n        let playstate = this.getPlayState();\r\n        if (playstate !== \"finished\") {\r\n            this.beginEvent();\r\n            this.animationFrame = requestAnimationFrame(this.loop);\r\n            this.all(anim => anim.playState == \"paused\" && anim.play());\r\n            this.emit(\"play\", playstate, this);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause Animation\r\n     */\r\n    public pause(): Animate {\r\n        let playstate = this.getPlayState();\r\n        if (playstate !== \"finished\") {\r\n            this.all(anim => anim.playState == \"running\" && anim.pause());\r\n            window.cancelAnimationFrame(this.animationFrame);\r\n            this.emit(\"pause\", playstate, this);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all Animations\r\n     */\r\n    public reset() {\r\n        this.setProgress(0);\r\n        this.beginEvent();\r\n\r\n        if (this.options.autoplay) this.play();\r\n        else this.pause();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels all Animations\r\n     */\r\n    public cancel() {\r\n        this.all(anim => anim.cancel());\r\n        window.cancelAnimationFrame(this.animationFrame);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Force complete all Animations\r\n     */\r\n    public finish() {\r\n        this.all(anim => anim.finish());\r\n        window.cancelAnimationFrame(this.animationFrame);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels & Clears all Animations\r\n     */\r\n    public stop() {\r\n        this.cancel();\r\n        this.animations.clear();\r\n        while (this.targets.length) this.targets.pop();\r\n        this.mainElement = undefined;\r\n        this.emit(\"stop\");\r\n    }\r\n\r\n    /**\r\n     * Returns an Array of targets\r\n     */\r\n    public getTargets(): Node[] {\r\n        return this.targets;\r\n    }\r\n\r\n    /**\r\n     * Get a specific Animation from an Animate instance\r\n     */\r\n    public getAnimation(element: HTMLElement): Animation {\r\n        return this.animations.get(element);\r\n    }\r\n\r\n    /**\r\n     * Returns the timings of an Animation, given a target\r\n     * E.g. { duration, endDelay, delay, iterations, iterationStart, direction, easing, fill, etc... }\r\n     */\r\n    public getTiming(target: HTMLElement | Animation): AnimationOptions & EffectTiming {\r\n        let animation = target instanceof Animation ? target : this.getAnimation(target);\r\n        let keyframeOptions = this.computedOptions.get(animation) ?? {};\r\n        let timings = animation.effect?.getTiming() ?? {};\r\n        let options = this.getOptions();\r\n\r\n        return { ...DefaultAnimationOptions, ...options, ...timings, ...keyframeOptions };\r\n    }\r\n\r\n    /**\r\n     * Returns the total duration of Animation\r\n     */\r\n    public getTotalDuration(): number {\r\n        return this.totalDuration;\r\n    }\r\n\r\n    /**\r\n     * Returns the current time of the Main Animation\r\n     */\r\n    public getCurrentTime(): number {\r\n        return this.mainAnimation.currentTime;\r\n    }\r\n\r\n    /**\r\n     * Returns the Animation progress as a fraction of the current time / duration * 100\r\n     */\r\n    public getProgress() {\r\n        return (this.getCurrentTime() / this.totalDuration) * 100;\r\n    }\r\n\r\n    /**\r\n     * Return the playback speed of the animation\r\n     */\r\n    public getSpeed(): number {\r\n        return this.mainAnimation.playbackRate;\r\n    }\r\n\r\n    /**\r\n     * Returns the current playing state\r\n     */\r\n    public getPlayState(): \"idle\" | \"running\" | \"paused\" | \"finished\" {\r\n        return this.mainAnimation.playState;\r\n    }\r\n\r\n    /**\r\n     * Get the options of an Animate instance\r\n     */\r\n    public getOptions(): AnimationOptions {\r\n        return this.options;\r\n    }\r\n\r\n    /**\r\n     * Set the current time of the Main Animation\r\n     */\r\n    public setCurrentTime(time: number): Animate {\r\n        this.all(anim => { anim.currentTime = time; });\r\n        this.emit(\"update\", this.getProgress());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the Animation progress as a value from 0 to 100\r\n     */\r\n    public setProgress(percent: number): Animate {\r\n        let time = (percent / 100) * this.totalDuration;\r\n        this.setCurrentTime(time);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the playback speed of an Animation\r\n     */\r\n    public setSpeed(speed: number = 1): Animate {\r\n        this.all(anim => { anim.playbackRate = speed; });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for a given event\r\n     */\r\n    public on(events: AnimationEvents | EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.on(events, callback, scope ?? this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from an event\r\n     */\r\n    public off(events: AnimationEvents | EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.off(events, callback, scope ?? this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call all listeners within an event\r\n     */\r\n    public emit(events: AnimationEvents | string | any[], ...args: any): Animate {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n\r\n\r\n    /** Returns the Animate options, as JSON  */\r\n    public toJSON(): AnimationOptions {\r\n        return this.getOptions();\r\n    }\r\n\r\n    /**\r\n     * The Symbol.toStringTag well-known symbol is a string valued property that is used\r\n     * in the creation of the default string description of an object.\r\n     * It is accessed internally by the Object.prototype.toString() method.\r\n     */\r\n    get [Symbol.toStringTag]() {\r\n        return `Animate`;\r\n    }\r\n}\r\n\r\n/** Creates a new Animate instance */\r\nexport const animate = (options: AnimationOptions = {}): Animate => {\r\n    return new Animate(options);\r\n};\r\n\r\nexport default animate;\r\n", "export const toArr = (val: any) => Array.prototype.slice.call(val);\r\nexport default toArr;\r\n", "import { Service, animate } from \"@okikio/native\";\r\nimport { toArr } from \"../toArr\";\r\n\r\nexport class IntroAnimation extends Service {\r\n    protected elements: Array<Element>;\r\n    protected rootElement: HTMLElement;\r\n    entries: Array<Element>;\r\n    observer: IntersectionObserver;\r\n    splashscreen: boolean;\r\n\r\n    public init() {\r\n        super.init();\r\n\r\n        // Elements\r\n        this.elements = toArr(document.querySelectorAll(\".intro-animation\"));\r\n        this.entries = [];\r\n\r\n        let scrollTop = window.scrollY;\r\n        let scrollBottom = window.scrollY + window.innerHeight;\r\n        for (let el of this.elements) {\r\n            let { bottom, top } = el.getBoundingClientRect();\r\n            if ((bottom > scrollTop && bottom < scrollBottom) ||\r\n                (top < scrollBottom && top > scrollTop)) {\r\n                this.entries.push(el);\r\n            }\r\n        }\r\n    }\r\n\r\n    public newPage() {\r\n\r\n        this.init();\r\n        this.prepareToShow();\r\n    }\r\n\r\n    public initEvents() {\r\n        this.emitter.on(\r\n            \"BEFORE_SPLASHSCREEN_HIDE\",\r\n            this.prepareToShow,\r\n            this\r\n        );\r\n        this.emitter.on(\"CONTENT_REPLACED\", this.newPage, this);\r\n        this.emitter.on(\r\n            \"AFTER_SPLASHSCREEN_HIDE BEFORE_TRANSITION_IN\",\r\n            this.show,\r\n            this\r\n        );\r\n    }\r\n\r\n    public stopEvents() {\r\n        this.emitter.off(\r\n            \"BEFORE_SPLASHSCREEN_HIDE\",\r\n            this.prepareToShow,\r\n            this\r\n        );\r\n        this.emitter.off(\"CONTENT_REPLACED\", this.newPage, this);\r\n        this.emitter.off(\r\n            \"AFTER_SPLASHSCREEN_HIDE BEFORE_TRANSITION_IN\",\r\n            this.show,\r\n            this\r\n        );\r\n    }\r\n\r\n    public uninstall() {\r\n        requestAnimationFrame(() => {\r\n            for (let el of this.entries) {\r\n                (el as HTMLElement).style.opacity = \"1\";\r\n            }\r\n        });\r\n    }\r\n\r\n    public prepareToShow() {\r\n        requestAnimationFrame(() => {\r\n            for (let el of this.entries) {\r\n                (el as HTMLElement).style.opacity = \"0\";\r\n            }\r\n        });\r\n    }\r\n\r\n    public async show() {\r\n        return await animate({\r\n            target: this.entries as HTMLElement[],\r\n            opacity: [0, 1],\r\n            delay(i: number) {\r\n                return 300 * (i);\r\n            },\r\n            onfinish: (el: { style: { opacity: string, visibility: string } }) => {\r\n                requestAnimationFrame(() => {\r\n                    el.style.opacity = \"1\";\r\n                });\r\n            },\r\n            easing: \"ease-out\",\r\n            duration: 650,\r\n        });\r\n    }\r\n}\r\n", "import { Service } from \"@okikio/native\";\r\nimport { toArr } from \"../toArr\";\r\n\r\nexport class Navbar extends Service {\r\n    public navbar: HTMLElement;\r\n    public elements: HTMLElement[];\r\n    public menu: HTMLElement;\r\n\r\n    public init() {\r\n        // Elements\r\n        this.navbar = document.querySelector(\".navbar\") as HTMLElement;\r\n        this.elements = toArr(this.navbar.querySelectorAll(\".navbar-item\"));\r\n        this.menu = document.querySelector(\".navbar-menu\") as HTMLElement;\r\n\r\n        this.click = this.click.bind(this);\r\n    }\r\n\r\n    public validLink(el: HTMLAnchorElement): boolean {\r\n        return (\r\n            el &&\r\n            el.tagName &&\r\n            (el.tagName.toLowerCase() === \"a\" ||\r\n                el.tagName.toLowerCase() === \"button\")\r\n        );\r\n    }\r\n\r\n    public getLink({ target }): HTMLAnchorElement {\r\n        let el = target as HTMLAnchorElement;\r\n        while (el && !this.validLink(el))\r\n            el = (el as HTMLElement).parentNode as HTMLAnchorElement;\r\n\r\n        // Check for a valid link\r\n        if (!el) return;\r\n        return el;\r\n    }\r\n\r\n    public click(event: Event) {\r\n        let el = this.getLink(event);\r\n        if (!el) return;\r\n\r\n        if (el.classList.contains(\"navbar-menu\"))\r\n            this.navbar.classList.toggle(\"active\");\r\n        else if (el.classList.contains(\"navbar-link\"))\r\n            this.navbar.classList.remove(\"active\");\r\n    }\r\n\r\n    public activateLink() {\r\n        let { href } = window.location;\r\n\r\n        for (let item of this.elements) {\r\n            let itemHref =\r\n                item.getAttribute(\"data-path\") ||\r\n                (item as HTMLAnchorElement).href;\r\n            if (!itemHref || itemHref.length < 1) continue;\r\n\r\n            let URLmatch = new RegExp(itemHref).test(href);\r\n            let isActive = item.classList.contains(\"active\");\r\n            if (!(URLmatch && isActive)) {\r\n                item.classList.toggle(\"active\", URLmatch);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public initEvents() {\r\n        this.navbar.addEventListener(\"click\", this.click);\r\n        this.emitter.on(\"READY\", this.activateLink, this);\r\n        this.emitter.on(\"GO\", this.activateLink, this);\r\n    }\r\n\r\n    public stopEvents() {\r\n        this.navbar.removeEventListener(\"click\", this.click);\r\n        this.emitter.off(\"READY\", this.activateLink, this);\r\n        this.emitter.off(\"GO\", this.activateLink, this);\r\n    }\r\n\r\n    public uninstall() {\r\n        while (this.elements.length) this.elements.pop();\r\n        this.elements = undefined;\r\n        this.menu = undefined;\r\n        this.navbar = undefined;\r\n    }\r\n}\r\n", "import { Service } from \"@okikio/native\";\r\nimport { toArr } from \"../toArr\";\r\n\r\nexport class Image extends Service {\r\n    images: HTMLImageElement[];\r\n    WebpSupport = false;\r\n\r\n    public init() {\r\n        super.init();\r\n        this.resize = this.resize.bind(this);\r\n        this.before_transition_out = this.before_transition_out.bind(this);\r\n        this.content_insert = this.content_insert.bind(this);\r\n\r\n        (async () => {\r\n            await this.test_webp();\r\n            this.get_images();\r\n            requestAnimationFrame(() => {\r\n                this.load_img();\r\n            });\r\n        })();\r\n    }\r\n\r\n    public get_images() {\r\n        this.images = toArr(document.querySelectorAll(\"figure.img\"));\r\n    }\r\n\r\n    public remove_images() {\r\n        while (this.images.length) this.images.pop();\r\n    }\r\n\r\n    public async test_webp() {\r\n        let check_webp_feature = (feature) => {\r\n            return new Promise((resolve, reject) => {\r\n                let kTestImages = {\r\n                    lossy: \"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\",\r\n                    lossless: \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\",\r\n                    alpha: \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\",\r\n                    animation: \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"\r\n                };\r\n\r\n                let img: HTMLImageElement | void = new window.Image();\r\n\r\n                // @ts-ignore\r\n                img.src = \"data:image/webp;base64,\" + kTestImages[feature];\r\n                // @ts-ignore\r\n                img.onload = () => {\r\n                    // @ts-ignore\r\n                    let result = (img.width > 0) && (img.height > 0);\r\n                    img = resolve(result);\r\n                };\r\n\r\n                // @ts-ignore\r\n                img.onerror = () => {\r\n                    img = reject(false);\r\n                };\r\n            });\r\n        };\r\n\r\n        // Quick test for webp support\r\n        try {\r\n            let result = await check_webp_feature(\"lossless\");\r\n            this.WebpSupport = result as boolean;\r\n        } catch (e) {\r\n            this.WebpSupport = false;\r\n            // Safari still doesn't support WebP\r\n            console.info(\r\n                \"Using JPG instead, of WEBP as this browser doesn't support WEBP.\"\r\n            );\r\n        }\r\n    }\r\n\r\n    public load_img() {\r\n        for (let elem of this.images) {\r\n            let img = elem.querySelector(\".img-core\") as HTMLImageElement;\r\n            let srcset = img.getAttribute(\"data-src\");\r\n            let srcWid = Math.max(Math.round(elem.clientWidth), 10);\r\n            let srcHei = Math.max(Math.round(elem.clientHeight), 10);\r\n\r\n            // Use the largest image dimensions it remembers\r\n            let maxW = img.hasAttribute(\"data-max-w\") ? img.getAttribute(\"data-max-w\") : 0;\r\n            if (Number(maxW) < Number(srcWid)) {\r\n                img.setAttribute(\"data-max-w\", \"\" + srcWid);\r\n                img.setAttribute(\"width\", \"\" + srcWid);\r\n                img.setAttribute(\"height\", \"\" + srcHei);\r\n            } else srcWid = Number(maxW);\r\n\r\n            let src = srcset.replace(/w_auto/, `w_${srcWid}`);\r\n            if (srcHei > srcWid) src = src.replace(/ar_4:3,/, `ar_3:4,`); // src = src.replace(/ar_4:3/, `ar_3:4`);\r\n            if (!this.WebpSupport) src = src.replace(\".webp\", \".jpg\");\r\n\r\n            // If nothing has changed don't bother\r\n            if (src === img.src) return;\r\n\r\n            // Ensure the image has loaded, then replace the small preview\r\n            img.src = src;\r\n            if (!elem.classList.contains(\"img-show\"))\r\n                (img.onload = () => { elem.classList.add(\"img-show\"); img.onload = undefined; img = undefined; }); // Hide the image preview\r\n\r\n        }\r\n    }\r\n\r\n    waitOnResize = false;\r\n    resize() {\r\n        if (!this.waitOnResize) {\r\n            let timer;\r\n            this.waitOnResize = true;\r\n            requestAnimationFrame(() => {\r\n                this.load_img();\r\n\r\n                // set a timeout to un-throttle\r\n                timer = window.setTimeout(() => {\r\n                    this.waitOnResize = false;\r\n                    timer = window.clearTimeout(timer);\r\n                }, 500);\r\n            });\r\n        }\r\n    }\r\n\r\n    public initEvents() {\r\n        window.addEventListener(\r\n            \"resize\", this.resize,\r\n            { passive: true }\r\n        );\r\n\r\n        this.emitter.on(\"BEFORE_TRANSITION_OUT\", this.before_transition_out);\r\n        this.emitter.on(\"CONTENT_INSERT\", this.content_insert);\r\n    }\r\n\r\n    public content_insert() {\r\n        this.get_images();\r\n        this.load_img();\r\n    }\r\n\r\n    public before_transition_out() {\r\n        this.remove_images();\r\n    }\r\n\r\n    public stopEvents() {\r\n        window.removeEventListener(\"resize\", this.resize);\r\n\r\n        this.emitter.off(\"BEFORE_TRANSITION_OUT\", this.before_transition_out);\r\n        this.emitter.off(\"CONTENT_INSERT\", this.content_insert);\r\n    }\r\n\r\n    public uninstall() {\r\n        this.remove_images();\r\n        this.images = undefined;\r\n    }\r\n}\r\n", "import { Service } from \"@okikio/native\";\r\nimport { toArr } from \"../toArr\";\r\n\r\n//== Blocks\r\nlet lerp = (a: number, b: number, n: number): number => (1 - n) * a + n * b;\r\nexport class Carousel extends Service {\r\n    public ease: number = 0.125;\r\n    public speed: number = 1.95;\r\n\r\n    public rootElement: HTMLElement;\r\n    public carouselBtn: HTMLElement;\r\n    public prevBtn: HTMLElement;\r\n    public nextBtn: HTMLElement;\r\n\r\n    public container: HTMLElement;\r\n    public viewport: HTMLElement;\r\n    public slides: HTMLElement[];\r\n\r\n    public dotContainer: HTMLElement;\r\n    public dots: HTMLElement[];\r\n    public dot: HTMLElement;\r\n\r\n    public viewportWidth: number;\r\n    public width: number;\r\n\r\n    public rAF: number;\r\n\r\n    public lastIndex: number;\r\n    public index: number;\r\n    public slideLen: number;\r\n\r\n    public currentX: number;\r\n    public lastX: number;\r\n    public maxX: number;\r\n    public minX: number;\r\n\r\n    public offX: number;\r\n    public onX: number;\r\n    public onY: number;\r\n    public center: number;\r\n\r\n    public isDragging: boolean;\r\n    public snapOnce: boolean;\r\n    public isScrolling = false;\r\n    public waitForResize: boolean;\r\n\r\n    public init() {\r\n        this.rootElement = document.querySelector(`#Carousel`) as HTMLElement;\r\n        if (this.rootElement) {\r\n            this.rootElement.classList.add(\"active\");\r\n            this.container = this.rootElement.getElementsByClassName(\r\n                \"carousel-container\"\r\n            )[0] as HTMLElement;\r\n            this.viewport = this.rootElement.getElementsByClassName(\r\n                \"carousel-viewport\"\r\n            )[0] as HTMLElement;\r\n            this.slides = toArr(this.rootElement.getElementsByClassName(\"carousel-item\"));\r\n            this.carouselBtn = this.rootElement.getElementsByClassName(\r\n                \"carousel-btn\"\r\n            )[0] as HTMLElement;\r\n            this.prevBtn = this.carouselBtn.getElementsByClassName(\r\n                \"prev-btn\"\r\n            )[0] as HTMLElement;\r\n            this.nextBtn = this.carouselBtn.getElementsByClassName(\r\n                \"next-btn\"\r\n            )[0] as HTMLElement;\r\n\r\n            this.dotContainer = this.rootElement.getElementsByClassName(\r\n                \"carousel-dots\"\r\n            )[0] as HTMLElement;\r\n            this.dots = toArr(this.rootElement.getElementsByClassName(\"carousel-dot\"));\r\n            this.dot = this.dots[0] as HTMLElement;\r\n\r\n            this.slideLen = this.slides.length;\r\n            this.center = window.innerWidth / 2;\r\n\r\n            this.viewportWidth = 0;\r\n            this.currentX = 0;\r\n            this.width = 0;\r\n\r\n            this.index = 0;\r\n            this.lastIndex = this.index;\r\n\r\n            this.lastX = 0;\r\n            this.maxX = 0;\r\n            this.minX = 0;\r\n\r\n            this.offX = 0;\r\n            this.onX = 0;\r\n            this.onY = 0;\r\n\r\n            this.snapOnce = false;\r\n            this.isDragging = false;\r\n            this.isScrolling = false;\r\n            this.waitForResize = false;\r\n\r\n            this.setBounds();\r\n            this.clearDots();\r\n            this.setDots();\r\n            this.select(this.index);\r\n\r\n            [\r\n                \"on\",\r\n                \"off\",\r\n                \"run\",\r\n                \"next\",\r\n                \"prev\",\r\n                \"scroll\",\r\n                \"setPos\",\r\n                \"resize\",\r\n                \"keypress\",\r\n                \"dotClick\",\r\n            ].forEach((key: string) => {\r\n                this[key] = this[key]?.bind(this);\r\n            });\r\n\r\n            this.setHeight();\r\n            this.addCarouselEvents();\r\n        }\r\n    }\r\n\r\n    public setDots() {\r\n        requestAnimationFrame(() => {\r\n            for (let i = 0; i < this.slideLen; i++) {\r\n                let newDot = this.dot.cloneNode() as HTMLElement;\r\n                if (i === this.index) newDot.classList.add(\"active\");\r\n                newDot.setAttribute(\"data-index\", `${i}`);\r\n                this.dotContainer.appendChild(newDot);\r\n                this.dots[i] = newDot;\r\n                newDot = undefined;\r\n            }\r\n        });\r\n    }\r\n\r\n    public setActiveDot() {\r\n        requestAnimationFrame(() => {\r\n            this.dots[this.lastIndex].classList.remove(\"active\");\r\n            this.dots[this.index].classList.add(\"active\");\r\n        });\r\n    }\r\n\r\n    public clearDots() {\r\n        requestAnimationFrame(() => {\r\n            for (let i = this.dots.length; --i >= 0;) {\r\n                this.dots[i].classList.remove(\"active\");\r\n                this.dots[i].removeAttribute(\"data-index\");\r\n                this.dots[i].remove();\r\n                this.dots.pop();\r\n            }\r\n        });\r\n    }\r\n\r\n    public setHeight() {\r\n        requestAnimationFrame(() => {\r\n            let maxHeight = this.slides[0].getBoundingClientRect().height;\r\n            for (let i = 0; i < this.slideLen; i++) {\r\n                let height = this.slides[i].scrollHeight;\r\n                if (height > maxHeight) maxHeight = height;\r\n            }\r\n\r\n            this.container.style.height = `${maxHeight}px`;\r\n        });\r\n    }\r\n\r\n    public setBounds() {\r\n        const { width } = this.slides[0].getBoundingClientRect();\r\n\r\n        this.width = width;\r\n        this.viewportWidth = this.width * this.slideLen;\r\n        this.maxX = -(this.viewportWidth - window.innerWidth + this.width / 4);\r\n        this.minX = this.width / 4;\r\n        this.setHeight();\r\n    }\r\n\r\n    public setPos(e: MouseEvent | TouchEvent | number) {\r\n        if (!this.isDragging) return;\r\n        let touches = (e as TouchEvent).changedTouches;\r\n        if (window.TouchEvent && e instanceof window.TouchEvent) {\r\n            e.stopPropagation();\r\n            let deltaX = Math.abs(\r\n                this.onX - touches[touches.length - 1].clientX\r\n            );\r\n            let deltaY = Math.abs(\r\n                this.onY - touches[touches.length - 1].clientY\r\n            );\r\n\r\n            // If vertically scrolling using touch, don't move horizontally & visa-versa\r\n            if (deltaX < deltaY) return;\r\n        }\r\n\r\n        let x =\r\n            window.MouseEvent && e instanceof window.MouseEvent\r\n                ? e.clientX\r\n                : typeof e === \"number\"\r\n                    ? e\r\n                    : touches[touches.length - 1].clientX;\r\n        this.setCurrentX(this.offX + (x - this.onX) * this.speed);\r\n\r\n        if (this.rAF === null) this.requestAnimationFrame(); //\r\n    }\r\n\r\n    public on(e: MouseEvent | TouchEvent | number) {\r\n        let touches = (e as TouchEvent).changedTouches;\r\n        if (window.TouchEvent && e instanceof window.TouchEvent)\r\n            e.stopPropagation();\r\n\r\n        this.isDragging = true;\r\n        this.onX =\r\n            window.MouseEvent && e instanceof window.MouseEvent\r\n                ? e.clientX\r\n                : typeof e === \"number\"\r\n                    ? e\r\n                    : touches[touches.length - 1].clientX;\r\n        this.onY =\r\n            window.MouseEvent && e instanceof window.MouseEvent\r\n                ? e.clientY\r\n                : typeof e === \"number\"\r\n                    ? 0\r\n                    : touches[touches.length - 1].clientY;\r\n        this.rootElement.classList.add(\"is-grabbing\");\r\n\r\n        if (this.rAF === null) this.requestAnimationFrame(); //\r\n    }\r\n\r\n    public parsePercent(value: number) {\r\n        return (value * this.viewportWidth) / 100;\r\n    }\r\n\r\n    public closest() {\r\n        let minDist: number, closest: number;\r\n        const difference = this.parsePercent(this.currentX);\r\n        for (let i = 0; i < this.slideLen; i++) {\r\n            const dist = Math.abs(i * this.width + difference);\r\n\r\n            if (dist < minDist || typeof minDist == \"undefined\") {\r\n                minDist = dist;\r\n                closest = i;\r\n            }\r\n        }\r\n\r\n        return closest;\r\n    }\r\n\r\n    public snap() {\r\n        let closest = this.closest();\r\n        this.select(closest);\r\n    }\r\n\r\n    public off(e?: TouchEvent | MouseEvent) {\r\n        if (window.TouchEvent && e instanceof window.TouchEvent)\r\n            e.stopPropagation();\r\n\r\n        this.snap();\r\n        this.isDragging = false;\r\n        this.offX = this.parsePercent(this.currentX);\r\n        this.rootElement.classList.remove(\"is-grabbing\");\r\n        this.onX = 0;\r\n        this.onY = 0;\r\n\r\n        if (this.rAF === null) this.requestAnimationFrame(); //\r\n    }\r\n\r\n    public toPercent(value: number) {\r\n        return (value / this.viewportWidth) * 100;\r\n    }\r\n\r\n    public setCurrentX(value: number) {\r\n        this.currentX = this.toPercent(value);\r\n\r\n        let maxX = this.toPercent(this.maxX);\r\n        let minX = this.toPercent(this.minX);\r\n        this.currentX = Math.min(Math.max(this.currentX, maxX), minX);\r\n    }\r\n\r\n    public select(index: number) {\r\n        this.lastIndex = this.index;\r\n        this.index = Math.min(Math.max(index, 0), this.slideLen - 1);\r\n        this.setCurrentX(-this.index * this.width);\r\n        this.setActiveDot();\r\n        this.setHeight();\r\n\r\n        if (this.rAF === null) this.requestAnimationFrame(); //\r\n    }\r\n\r\n    public run() {\r\n        this.requestAnimationFrame();\r\n\r\n        let lastX = Math.floor(Math.abs(this.lastX) * 100) / 100;\r\n        let currentX = Math.floor(Math.abs(this.currentX) * 100) / 100;\r\n        console.log(\"Carousel is Running\"); // , { lastX, currentX }\r\n\r\n        // No point in requesting animation frame, when you know nothing is going to change\r\n        if (Math.abs(lastX - currentX) > 0) {\r\n            if (!this.isScrolling && !this.snapOnce) {\r\n                this.snap();\r\n                this.snapOnce = true;\r\n            }\r\n\r\n            this.viewport.style.transform = `translate3d(${this.lastX}%, 0, 0)`;\r\n        } else {\r\n            this.cancelAnimationFrame();\r\n            lastX = undefined;\r\n            currentX = undefined;\r\n        }\r\n\r\n        this.isScrolling = false;\r\n        this.lastX = lerp(this.lastX, this.currentX, this.ease);\r\n    }\r\n\r\n    public requestAnimationFrame() {\r\n        this.rAF = window.requestAnimationFrame(this.run);\r\n    }\r\n\r\n    public initEvents() {\r\n        this.emitter.on(\"BEFORE_TRANSITION_OUT\", this.removeCarouselEvents, this);\r\n        this.emitter.on(\"CONTENT_REPLACED\", this.init, this);\r\n    }\r\n\r\n    public addCarouselEvents() {\r\n        this.run();\r\n\r\n        this.nextBtn.addEventListener(\"click\", this.next, false);\r\n        this.prevBtn.addEventListener(\"click\", this.prev, false);\r\n\r\n        this.dotContainer.addEventListener(\"click\", this.dotClick, false);\r\n\r\n        this.rootElement.addEventListener(\"mousedown\", this.on, {\r\n            passive: true,\r\n        });\r\n        window.addEventListener(\"mousemove\", this.setPos, { passive: true });\r\n        window.addEventListener(\"mouseup\", this.off, { passive: true });\r\n\r\n        this.rootElement.addEventListener(\"touchstart\", this.on, {\r\n            passive: true,\r\n        });\r\n        window.addEventListener(\"touchmove\", this.setPos, { passive: true });\r\n        window.addEventListener(\"touchend\", this.off, { passive: true });\r\n\r\n        this.rootElement.addEventListener(\"wheel\", this.scroll, {\r\n            passive: false,\r\n        });\r\n        window.addEventListener(\"keydown\", this.keypress, false);\r\n        window.addEventListener(\"resize\", this.resize, { passive: true });\r\n    }\r\n\r\n    public removeCarouselEvents() {\r\n        if (this.rootElement) {\r\n            this.cancelAnimationFrame();\r\n\r\n            this.nextBtn.removeEventListener(\"click\", this.next);\r\n            this.prevBtn.removeEventListener(\"click\", this.prev);\r\n\r\n            this.dotContainer.removeEventListener(\r\n                \"click\",\r\n                this.dotClick\r\n            );\r\n\r\n            this.rootElement.removeEventListener(\"mousedown\", this.on);\r\n            window.removeEventListener(\"mousemove\", this.setPos);\r\n            window.removeEventListener(\"mouseup\", this.off);\r\n\r\n            this.rootElement.removeEventListener(\"touchstart\", this.on);\r\n            window.removeEventListener(\"touchmove\", this.setPos);\r\n            window.removeEventListener(\"touchend\", this.off);\r\n\r\n            this.rootElement.removeEventListener(\"wheel\", this.scroll);\r\n            window.removeEventListener(\"keydown\", this.keypress);\r\n            window.removeEventListener(\"resize\", this.resize);\r\n            this.rootElement = undefined;\r\n            console.log(\"Remove Carousel Events\");\r\n        }\r\n    }\r\n\r\n    public keypress(evt: KeyboardEvent) {\r\n        if (evt.code === \"ArrowRight\") this.next();\r\n        if (evt.code === \"ArrowLeft\") this.prev();\r\n    }\r\n\r\n    public scroll(evt: any) {\r\n        this.isScrolling = true;\r\n        this.snapOnce = false;\r\n        if (this.isDragging) return;\r\n\r\n        let { deltaX } = evt;\r\n        let currentX = this.parsePercent(this.currentX);\r\n        this.setCurrentX(currentX - deltaX * this.speed);\r\n        if (Math.abs(deltaX) > 0) evt.preventDefault();\r\n        if (this.rAF === null) this.requestAnimationFrame();\r\n\r\n    }\r\n\r\n    private dotClick(e: MouseEvent) {\r\n        let target = e.target as HTMLElement;\r\n        if (target.classList && target.classList.contains(\"carousel-dot\")) {\r\n            let index = +target.getAttribute(\"data-index\");\r\n            this.select(index);\r\n        }\r\n    }\r\n\r\n    private prev() {\r\n        this.select(this.index - 1);\r\n    }\r\n\r\n    private next() {\r\n        this.select(this.index + 1);\r\n    }\r\n\r\n    public cancelAnimationFrame() {\r\n        window.cancelAnimationFrame(this.rAF);\r\n        this.rAF = null;\r\n    }\r\n\r\n    public stopEvents() {\r\n        this.removeCarouselEvents();\r\n        this.emitter.off(\"BEFORE_TRANSITION_OUT\", this.removeCarouselEvents, this);\r\n        this.emitter.off(\"CONTENT_REPLACED\", this.init, this);\r\n    }\r\n\r\n    public uninstall() {\r\n        this.container = undefined;\r\n        this.viewport = undefined;\r\n        this.slides = undefined;\r\n\r\n        this.carouselBtn = undefined;\r\n        this.prevBtn = undefined;\r\n        this.nextBtn = undefined;\r\n\r\n        this.dotContainer = undefined;\r\n        this.dots = undefined;\r\n        this.dot = undefined;\r\n\r\n        this.slideLen = 0;\r\n        this.center = 0;\r\n\r\n        this.viewportWidth = 0;\r\n        this.currentX = 0;\r\n        this.width = 0;\r\n\r\n        this.index = 0;\r\n        this.lastIndex = 0;\r\n\r\n        this.lastX = 0;\r\n        this.maxX = 0;\r\n        this.minX = 0;\r\n\r\n        this.offX = 0;\r\n        this.onX = 0;\r\n        this.onY = 0;\r\n\r\n        this.snapOnce = false;\r\n        this.isDragging = false;\r\n        this.isScrolling = false;\r\n        this.waitForResize = false;\r\n\r\n        this.rootElement = undefined;\r\n    }\r\n\r\n    public resize() {\r\n        if (!this.waitForResize) {\r\n            let timer: number | void;\r\n            this.waitForResize = true;\r\n            requestAnimationFrame(() => {\r\n                this.setBounds();\r\n\r\n                // set a timeout to un-throttle\r\n                timer = window.setTimeout(() => {\r\n                    this.waitForResize = false;\r\n                    timer = window.clearTimeout(timer as number);\r\n                }, 500);\r\n            });\r\n\r\n        }\r\n    }\r\n}\r\n", "import { ITransition, ITransitionData, animate } from \"@okikio/native\";\r\n\r\n//== Transitions\r\nexport const Fade: ITransition = {\r\n    name: \"default\",\r\n    duration: 350,\r\n    scrollable: true,\r\n\r\n    out({ from, trigger }: ITransitionData) {\r\n        let { duration } = this;\r\n        let fromWrapper = from.wrapper;\r\n        return animate({\r\n            target: fromWrapper,\r\n            keyframes: [\r\n                {\r\n                    transform: \"translateY(0)\",\r\n                    opacity: 1,\r\n                },\r\n                {\r\n                    opacity: 0,\r\n                    transform: `translateY(${window.scrollY > 100 &&\r\n                        !/back|popstate|forward/.test(trigger as string)\r\n                        ? 100\r\n                        : 0\r\n                        }px)`,\r\n                },\r\n            ],\r\n            easing: \"out\",\r\n            duration,\r\n        });\r\n    },\r\n\r\n    in({ to, scroll }: ITransitionData) {\r\n        let { duration } = this;\r\n        let toWrapper = to.wrapper;\r\n\r\n        window.scroll(scroll.x, scroll.y);\r\n        return animate({\r\n            target: toWrapper,\r\n            opacity: [0, 1],\r\n            easing: \"in\",\r\n            duration,\r\n        });\r\n    }\r\n};\r\n", "import { PJAX, App, TransitionManager, HistoryManager, PageManager } from \"@okikio/native\";\r\nimport { toArr } from \"./toArr\";\r\n\r\nimport { IntroAnimation } from \"./services/IntroAnimation\";\r\nimport { Navbar } from \"./services/Navbar\";\r\nimport { Image } from \"./services/Image\";\r\n\r\nimport { Carousel } from \"./services/Carousel\";\r\nimport { Fade } from \"./transitions/Fade\";\r\n\r\nlet app: App = new App();\r\napp\r\n    .set(\"HistoryManager\", new HistoryManager())\r\n    .set(\"PageManager\", new PageManager())\r\n    .set(\"TransitionManager\", new TransitionManager([\r\n        [Fade.name, Fade]\r\n    ]))\r\n    .set(\"PJAX\", new PJAX())\r\n    .add(new IntroAnimation())\r\n    .add(new Image())\r\n\r\n    .set(\"Navbar\", new Navbar())\r\n    .add(new Carousel());\r\n\r\ntry {\r\n    const navbar: HTMLElement = document.querySelector(\".navbar\");\r\n    const navHeight = navbar.getBoundingClientRect().height;\r\n\r\n    let layers: HTMLElement[];\r\n    let layer: HTMLElement | null;\r\n    let topOfLayer: number;\r\n\r\n    let elToScrollTo: HTMLElement;\r\n    let toTopEl: HTMLElement;\r\n    let scrollDownEl: HTMLElement;\r\n    let wait = false;\r\n\r\n    const ScrollEventListener = () => {\r\n        if (!wait) {\r\n            wait = true;\r\n            requestAnimationFrame(() => {\r\n                let scrollTop = window.scrollY + navHeight;\r\n                if (scrollTop >= topOfLayer) {\r\n                    navbar.classList.add(\"focus\");\r\n                } else navbar.classList.remove(\"focus\");\r\n                wait = false;\r\n            });\r\n        }\r\n    };\r\n\r\n    const ScrollToTopEventListener = () => {\r\n        window.scroll({\r\n            top: 0,\r\n            behavior: \"smooth\",\r\n        });\r\n    };\r\n\r\n    const ScrollDownEventListener = () => {\r\n        if (elToScrollTo)\r\n            elToScrollTo.scrollIntoView({ behavior: \"smooth\" });\r\n    };\r\n\r\n\r\n    const init = () => {\r\n        layers = toArr(document.querySelectorAll(\".layer\"));\r\n        layer = layers[0] || null;\r\n        topOfLayer = layer ? layer.getBoundingClientRect().top + window.pageYOffset - navHeight / 4 : 0;\r\n\r\n        // navbar.classList.remove(\"focus\");\r\n        navbar.classList.remove(\"active\");\r\n        ScrollEventListener();\r\n\r\n        // On the index, and all service pages, use a light color scheme for text\r\n        let { pathname } = window.location;\r\n        if (/(index(.html)?|\\/$)|(services\\/+)/g.test(pathname))\r\n            navbar.classList.add(\"light\");\r\n        else if (navbar.classList.contains(\"light\")) navbar.classList.remove(\"light\");\r\n\r\n\r\n        // On the about, services, contact, and 404 pages use a dark color scheme for text\r\n        if (/(about(.html)?)|(services(.html)?$)|(contact(.html)?)/g.test(pathname) ||\r\n            document.title.includes(\"404\"))\r\n            navbar.classList.add(\"dark\");\r\n        else if (navbar.classList.contains(\"dark\")) navbar.classList.remove(\"dark\");\r\n\r\n\r\n        toTopEl = document.querySelector(\".back-to-top\");\r\n        if (toTopEl)\r\n            toTopEl.addEventListener(\"click\", ScrollToTopEventListener);\r\n\r\n        scrollDownEl = document.querySelector(\".scroll-btn\");\r\n        if (scrollDownEl) {\r\n            elToScrollTo = document.querySelector(\".scroll-point\");\r\n            scrollDownEl.addEventListener(\"click\", ScrollDownEventListener);\r\n        }\r\n    };\r\n\r\n    const destroy = () => {\r\n        if (toTopEl) {\r\n            toTopEl.removeEventListener(\"click\", ScrollToTopEventListener);\r\n            toTopEl = undefined;\r\n        }\r\n\r\n        if (scrollDownEl) {\r\n            scrollDownEl.removeEventListener(\"click\", ScrollDownEventListener);\r\n\r\n            scrollDownEl = undefined;\r\n            elToScrollTo = undefined;\r\n        }\r\n\r\n        while (layers.length) layers.pop();\r\n        layers = undefined;\r\n        layer = undefined;\r\n        wait = false;\r\n    };\r\n\r\n    init();\r\n    window.addEventListener(\"scroll\", ScrollEventListener, { passive: true });\r\n\r\n    app.on(\"CONTENT_REPLACED\", init);\r\n    app.on(\"BEFORE_TRANSITION_OUT\", destroy);\r\n\r\n    app.boot();\r\n} catch (err) {\r\n    console.warn(\"[App] boot failed,\", err);\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
