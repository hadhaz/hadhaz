{"version":3,"sources":["template.js"],"names":["_","unescapeMap","&lt;","&gt;","&quot;","&#x27;","&#x60;","createEscaper","escaper","match","source","Object","keys","map","join","RegExp","testRegexp","replaceRegexp","string","test","replace","unescape","templateSettings","evaluate","interpolate","escape","noMatch","escapes","'","\\","\r","\n","â€¨","escapeRegExp","escapeChar","max","Math","min","template","text","settings","oldSettings","assign","render","index","length","matcher","offset","slice","variable","Function","e","data","call","this","argument"],"mappings":"aACA,IAAMA,EAAI,GAGNC,YAAc,CAAdA,QAAAA,IACAC,OAAS,IACTC,OAAQ,IACRC,SAHc,IAIdC,SAAU,IACVC,SAAU,KAKVC,cAAgB,SAAhBA,GACA,IAAIC,EAAU,SAAVA,GACA,OAAWC,EAAAA,IAGXC,EAAS,MAAQC,OAAOC,KAAKC,GAAKC,KAAK,KAAO,IAA9CJ,EAASK,OAAQJ,GACjBK,EAAaD,OAAOL,EAAxB,KACA,OAAIO,SAAaC,GAEbA,OADJA,EAAwB,MAAjBA,EAAiB,GAAA,GAAAA,EACXA,EAAUC,KAAOD,GAAUA,EAApCE,QAAAH,EAAAT,GAAAU,IAKRlB,EAAEqB,SAAWd,cAAcN,aAI3BD,EAAEsB,iBAAmB,CACjBC,SAAU,kBACVC,YAAa,mBACbC,OAAQ,oBASZ,IAAAC,QAAA,OAGIC,QAFU,CAGVC,IAAM,IACNC,KAAM,KACNC,KAAA,IACAC,KAAA,IANJC,SAAA,QASIC,SAAAA,SAGAA,aAAcN,4BADdO,WAAa,SAASzB,GAIxB0B,MAAMC,KAART,QAAAlB,IAKAT,EAAAmC,IAAAC,KAAAD,IACAnC,EAAAqC,IAAAD,KAAAC,IAMIrC,EAAAsC,SAAW,SAASC,EACfC,EAASf,IALTe,GAAYC,IAAaD,EAAWC,GAWzCD,EAAA7B,OAAA+B,OAAA,GAAAF,EAAAxC,EAAAsB,kBAGIZ,IAfRiC,EAeQjC,EAAcK,OAAO6B,EAChBJ,EAASf,QAASoB,SAAvBnC,QATC8B,EAAShB,aAAeE,SAAShB,QAW9Be,EAAQF,UAAAG,SAAAhB,QACRA,KAAAA,KAAU,KAAA,KAETkC,EAGIrB,EACLb,EAAU,SACb6B,EAEDnB,QAAA0B,EAAA,SAAArC,EAAAgB,EAAAD,EAAAD,EAAAwB,GAkBA,OA/BArC,GAAU6B,EAAKS,MAAMJ,EAAOG,GAAQ3B,QAAQa,aAAcC,YAC1DU,EAAQG,EAAStC,EAAMoC,OAF3BpB,EAiBUf,GAEV,cAAAe,EAAA,iCACcwB,EAELvC,GAAA,cAAAc,EAAA,uBAZID,IAiBTb,GAAA,OAAAa,EAAA,YAKAd,IAfJC,GAAU,OAsBV8B,EAAAS,WAAAvC,EAAA,mBAAAA,EAAA,OAjBAA,EAAS,4FAmBT4B,EAAA,gBAdA,IACIK,EAAS,IAAIO,SAASV,EAASS,UAAY,MAAO,IAAKvC,GAE3D,MAAOyC,GAEH,MADAA,EAAEzC,OAASA,EACLyC,EAGV,IAAIb,EAAW,SAASc,GACpB,OAAOT,EAAOU,KAAKC,KAAMF,EAAMpD,IAI/BuD,EAAWf,EAASS,UAAY,MAGpC,OAFAX,EAAS5B,OAAS,YAAc6C,EAAW,OAAS7C,EAAS,IAEtD4B","file":"template.min.js","sourcesContent":["// This is a port of underscorejs template engine\nconst _ = {};\n\n// List of HTML entities for escaping.\nvar unescapeMap = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#x27;': \"'\",\n    '&#x60;': '`'\n};\n\n// Functions for escaping and unescaping strings to/from HTML interpolation.\nvar createEscaper = function(map) {\n    var escaper = function(match) {\n        return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + Object.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n        string = string == null ? '' : '' + string;\n        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n};\n\n_.unescape = createEscaper(unescapeMap);\n\n// By default, Underscore uses ERB-style template delimiters, change the\n// following template settings to use alternative delimiters.\n_.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n};\n\n// When customizing `templateSettings`, if you don't want to define an\n// interpolation, evaluation or escaping regex, we need one that is\n// guaranteed not to match.\nvar noMatch = /(.)^/;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n};\n\nvar escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nvar escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n};\n\n_.max = Math.max;\n_.min = Math.min;\n\n// JavaScript micro-templating, similar to John Resig's implementation.\n// Underscore templating handles arbitrary delimiters, preserves whitespace,\n// and correctly escapes quotes within interpolated code.\n// NB: `oldSettings` only exists for backwards compatibility.\n_.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = Object.assign({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n        (settings.escape || noMatch).source,\n        (settings.interpolate || noMatch).source,\n        (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n        source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n        index = offset + match.length;\n\n        if (escape) {\n            source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n        }\n        else if (interpolate) {\n            source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n        }\n        else if (evaluate) {\n            source += \"';\\n\" + evaluate + \"\\n__p+='\";\n        }\n\n        // Adobe VMs need the match returned to produce the correct offset.\n        return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n        \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n        source + 'return __p;\\n';\n\n    var render;\n    try {\n        render = new Function(settings.variable || 'obj', '_', source);\n    }\n    catch (e) {\n        e.source = source;\n        throw e;\n    }\n\n    var template = function(data) {\n        return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n};\n"]}